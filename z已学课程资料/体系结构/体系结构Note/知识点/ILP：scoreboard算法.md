[计算机体系结构----计分板（scoreboard）算法](https://blog.csdn.net/Programmer_jzm/article/details/135496230)

---

Scoreboarding 是一种用于处理指令之间数据相关性和控制相关性以实现流水线并行度的算法，最早在CDC 6600中实现。Scoreboarding通过维护一个中央控制表（即“记分板”），实时追踪指令的状态、各寄存器的可用性、以及硬件资源（如功能单元）的使用情况，从而动态地调度指令以解决数据相关性冲突。其主要目标是管理指令的发射、执行和写回，从而在不依赖复杂硬件预测的情况下实现并行执行。

### Scoreboarding的四个流水级及相关冲突处理

Scoreboard算法将指令分成四个阶段：**Issue（发射）、Read Operands（读操作数）、Execution（执行）、Write Result（写结果）**。每个阶段都有具体的职责，分别处理不同类型的相关性问题（RAW、WAR、WAW），如下：

1. **Issue（发射阶段）**
   - **任务**：检查指令的资源可用性和写冲突。
   - **操作**：从指令队列中取出下一条指令，并检查是否有相应的硬件单元（功能单元）可用，以及指令所需的目标寄存器是否被其他指令使用。
   - **冲突处理**：
     - **WAW（Write After Write）**：在发射阶段检测WAW冲突。如果有其他尚未完成的指令要写同一个寄存器，Scoreboard会将新指令挂起，直到之前的写操作完成。
   - **结果**：如果资源和寄存器可用且无WAW冲突，则发射指令并分配硬件资源；否则，发射阶段挂起，指令等待。

2. **Read Operands（读操作数阶段）**
   - **任务**：检查是否所有操作数都可用，若是，则读取寄存器数据。
   - **操作**：当指令获得功能单元资源并且准备好读取操作数时，Scoreboard会检查操作数是否已经被前面的指令写入。
   - **冲突处理**：
     - **RAW（Read After Write）**：在此阶段解决。若某个操作数未写入（因为前面的指令还在执行），当前指令会被挂起，直到所有源操作数写入完毕。
   - **结果**：一旦所有操作数都可用，则进入执行阶段，否则继续等待。

3. **Execution（执行阶段）**
   - **任务**：指令在功能单元上完成其操作。
   - **操作**：指令执行计算或逻辑操作，通常为固定的执行时间（除非遇到分支或访存指令）。
   - **冲突处理**：执行阶段本身不涉及数据相关性冲突。
   - **结果**：执行结束后，指令进入写结果阶段。

4. **Write Result（写结果阶段）**
   - **任务**：将执行结果写入目标寄存器。
   - **操作**：检查是否所有先前指令已读取完目标寄存器的值；如果有未完成的读取操作，当前指令将被延迟写入。
   - **冲突处理**：
     - **WAR（Write After Read）**：在写结果阶段处理。如果之前有指令尚未读取该寄存器值，则当前指令的写操作会被挂起，直到所有读取完成。
   - **结果**：写回操作完成后，释放功能单元及寄存器的状态，指令执行完成。

---

### Scoreboard表结构

Scoreboard表是Scoreboarding算法的核心数据结构，用于记录每个指令、寄存器和功能单元的状态，从而进行实时依赖和冲突检测。其主要组成部分如下：

1. **指令状态表**  
   - 该表记录每条指令的当前阶段（如Issue、Read Operands、Execution、Write Result）以及每个阶段的状态，用于追踪指令的进度。
   - **示例列**：
     - `指令`: 表示指令的唯一标识符。
     - `状态`: 表示指令当前处于哪个阶段。

2. **功能单元状态表**
   - 功能单元状态表用于记录每个功能单元的状态，跟踪资源使用情况。每个功能单元都拥有一行，记录其繁忙状态、目标寄存器和源寄存器等信息，以判断资源依赖性。
   - **示例列**：
     - `Busy`：一个布尔值，表示该功能单元是否正在使用（即当前是否在执行指令）。
     - `Op`：指令操作类型（如ADD、MUL、DIV等）。
     - `Fi`：目标寄存器，当前指令将结果写入的寄存器。
     - `Fj` 和 `Fk`：源寄存器，当前指令所需的两个源寄存器。
     - `Qj` 和 `Qk`：表示所依赖的功能单元的标识符，如果某个操作数尚未计算完毕，则 `Qj` 或 `Qk` 会指向该操作数对应的功能单元；若该操作数已准备好，则 `Qj` 或 `Qk` 为空。
     - `Rj` 和 `Rk`：布尔标志，表示Fj和Fk的值是否已准备好。如果为`True`，表示可以从寄存器中读取该值；如果为`False`，则需要等待前一指令完成写入。

3. **寄存器状态表**
   - 该表记录每个寄存器的当前依赖关系，用于追踪哪些寄存器正在被哪个功能单元使用，避免WAW和RAW冲突。
   - **示例列**：
     - `寄存器`：记录寄存器标识符，如R1、R2等。
     - `功能单元`：指示当前正在或将要对该寄存器写操作的功能单元。

#### 记分板表的例子

假设我们有两个功能单元ADD和MUL，并有以下指令：  
- `I1: R1 = R2 + R3`
- `I2: R4 = R1 * R5`

| 功能单元 | Busy | Op  | Fi | Fj | Fk | Qj | Qk | Rj   | Rk   |
|----------|------|-----|----|----|----|----|----|------|------|
| ADD      | Yes  | ADD | R1 | R2 | R3 | -  | -  | True | True |
| MUL      | Yes  | MUL | R4 | R1 | R5 | ADD| -  | False| True |

| 寄存器 | 功能单元 |
|--------|----------|
| R1     | ADD      |
| R4     | MUL      |

在这个示例表中：
- ADD单元正执行 `I1`，目标是写入 `R1`，其依赖的操作数 `R2` 和 `R3` 均已准备好（`Rj=True`, `Rk=True`）。
- MUL单元正在 `I2` 中执行乘法运算，目标寄存器是 `R4`，其源寄存器 `R1` 和 `R5` 中，`R1` 由 ADD 单元负责，因此 `Rj=False` 表示它依赖 `ADD` 结果，`Rk=True` 表示 `R5` 已就绪。