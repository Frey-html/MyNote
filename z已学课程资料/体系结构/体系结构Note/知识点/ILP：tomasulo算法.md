[计算机体系结构-Tomasulo算法 - 知乎](https://zhuanlan.zhihu.com/p/499978902)
[体系结构学习笔记---白话理解Tomasulo算法-CSDN博客](https://blog.csdn.net/qq_41645482/article/details/109312513)
Tomasulo算法和Scoreboard（记分板）算法都是经典的动态指令调度方法，设计初衷都是为了提高指令流水线的执行效率、减少流水线停顿，并解决数据相关性问题（RAW、WAR、WAW）。然而，它们在设计细节上有显著差异，尤其是在如何处理寄存器、调度指令和解决数据相关性方面。

### Tomasulo算法概述

Tomasulo算法最早在IBM 360/91主机中实现，旨在通过动态调度和硬件级别的寄存器重命名来提高指令并行度。该算法使用了三个主要的数据结构：

1. **保留站（Reservation Stations）**：每个功能单元（如加法、乘法单元）前都有若干个保留站，用于暂存指令及其操作数。这使得指令可以在操作数就绪前进入保留站等待，而非被直接发射到功能单元。
  
2. **重命名寄存器（Register Renaming）**：Tomasulo引入了重命名机制，将寄存器依赖转化为保留站依赖。这种方法避免了WAR和WAW冲突，使得同一寄存器可以在不同指令中被重命名为不同的物理寄存器，从而实现寄存器复用。
  
3. **公共数据总线（Common Data Bus, CDB）**：用于广播功能单元执行结果，使得多个指令可以同时获取操作数，减少了操作数传递的延迟。

### Tomasulo算法的三个阶段

Tomasulo算法将指令的处理分为三个阶段：**Issue（发射）、Execute（执行）、Write Result（写结果）**。每个阶段的功能如下：

1. **Issue（发射阶段）**
   - **任务**：检查保留站是否可用，将指令和操作数发射到保留站中。
   - **操作**：如果目标功能单元的保留站有空位，指令会被放入保留站。每条指令的目的寄存器和操作数寄存器被重命名，以避免寄存器间的WAW和WAR冲突。
   - **数据依赖处理**：
     - Tomasulo使用寄存器重命名，因此可以完全避免WAR和WAW冲突。

2. **Execute（执行阶段）**
   - **任务**：当指令的所有操作数都已准备好，保留站将指令发射到功能单元执行。
   - **操作**：指令进入功能单元并执行计算。为了RAW依赖处理，如果操作数未准备好，指令会继续在保留站中等待。
   - **RAW处理**：如果某个操作数尚未准备好，保留站会监视公共数据总线（CDB）上的结果，并在目标操作数写入时捕获数据，解决RAW冲突。

3. **Write Result（写结果阶段）**
   - **任务**：指令执行完毕后，通过CDB将结果广播给等待该数据的其他保留站和寄存器。
   - **操作**：执行完成后，结果通过CDB广播给所有保留站，标记相关操作数为已准备，并写回目标寄存器。
   - **依赖解除**：依赖该结果的其他指令会得到通知并开始执行。

---

### Tomasulo算法的数据结构

1. **保留站（Reservation Stations）**：保留站存储每条指令的操作数、目的寄存器和操作符等。其字段通常包括：
   - `Busy`：标识该保留站是否被占用。
   - `Op`：指令操作类型（如ADD、SUB、MUL等）。
   - `Vj` 和 `Vk`：指令的两个操作数，若已准备好则存储值，否则为空。
   - `Qj` 和 `Qk`：指令操作数的来源保留站或功能单元标识符，如果操作数未准备好则指向对应保留站，否则为空。

2. **寄存器状态表**：寄存器状态表跟踪每个寄存器当前的重命名和依赖，帮助实现寄存器重命名，解决WAR和WAW冲突。
   - 每个寄存器记录其最近一次的写入指令所在的保留站，这样当其他指令引用该寄存器时，可以通过寄存器状态表找到最新的值来源。

3. **公共数据总线（CDB）**：CDB用于在写结果阶段广播结果，以便所有保留站和寄存器都能同时获取执行完的操作数，消除等待。

---

### Tomasulo算法与Scoreboard算法的比较

| 比较点            | Tomasulo算法                                           | Scoreboard算法                                       |
|-------------------|-------------------------------------------------------|------------------------------------------------------|
| **动态调度**      | 动态调度，允许乱序执行                                 | 动态调度，但依赖硬件控制同步，未使用重命名           |
| **寄存器重命名**  | 使用寄存器重命名，解决WAR和WAW冲突                     | 不使用寄存器重命名，只能在写回阶段避免WAR和WAW       |
| **数据依赖处理**  | RAW在执行阶段解决，WAR和WAW在发射时已解决             | RAW在Read Operands解决，WAR在写回阶段解决            |
| **冲突解决方式**  | 使用CDB广播结果，依赖保留站、寄存器状态表进行重命名   | 使用Scoreboard表解决依赖和冲突                       |
| **执行顺序**      | 乱序执行，乱序提交                                     | 乱序执行，但顺序提交                                 |
| **硬件开销**      | 需要保留站和CDB，硬件结构复杂，适用于现代处理器         | 硬件复杂度较低，适用于较简单的流水线结构             |

---

### 总结

- **Scoreboard** 适用于早期简单流水线结构，依赖中央Scoreboard表进行依赖管理。它不使用寄存器重命名，因此在应对WAR和WAW冲突时只能通过延迟写回来处理。虽然它也允许乱序执行，但由于缺少重命名机制，使得实际乱序执行受限。
  
- **Tomasulo** 则适用于更现代的处理器架构，它通过寄存器重命名和CDB消除了WAR和WAW依赖，使得更多指令可以并行执行，并使用CDB来实时广播数据。这一算法的设计极大地提高了指令吞吐量，适用于更复杂的指令集和并行计算环境。

总体来看，Tomasulo算法的设计更适合于现代乱序执行的处理器，而Scoreboard算法在较为简单的流水线系统中具有硬件实现的优势。



### Tips：如何解决WAW WAR重命名问题
保留站（Reservation Station）在 Tomasulo 算法中通过寄存器重命名来解决 WAR（Write After Read）和 WAW（Write After Write）数据冲突的问题。保留站的关键作用在于将指令的执行依赖从寄存器绑定中解耦，使得每条指令对寄存器的使用在硬件上“重命名”为对特定保留站的使用，从而动态管理并行指令的依赖。

#### 1. 保留站如何解决 WAW 冲突

在没有重命名机制的流水线系统中，如果多条指令要写入同一个寄存器，可能会发生 WAW 冲突。例如：

```plaintext
I1: R1 = R2 + R3
I2: R1 = R4 - R5
```

这两条指令在没有寄存器重命名时都会写回到 `R1`，如果 `I2` 比 `I1` 先完成，`I1` 的结果将被覆盖，导致数据错误。然而，在 Tomasulo 算法中，**保留站为每条指令提供了一个独立的存储位置**，每条指令在写回时不直接写入寄存器，而是写入自己的保留站（或在写回前通过重命名机制识别冲突）。只有当该指令完成写回、且寄存器状态表确认寄存器是空闲时，才会写回寄存器。因此：

- 每个寄存器的状态表记录了最后一个更新该寄存器的保留站。
- **这样，即使两个指令的目标寄存器相同，它们的写结果会在各自的保留站中等待从总线写入**，不会直接覆盖，避免了 WAW 冲突。

**而数据写回寄存器时，由于指令顺序发射，寄存器状态表的依赖被顺序更新，可以保证最后写会寄存器的是最后的写**

#### 2. 保留站如何解决 WAR 冲突

WAR 冲突发生在后续指令需要读取一个寄存器，而之前的指令还没有完成写回。例如：

```plaintext
I1: R1 = R2 + R3
I2: R4 = R1 + R5
```

在没有重命名机制的情况下，`I2` 可能会在 `I1` 完成写回前去读取 `R1`，读取到旧值而导致数据错误。在 Tomasulo 算法中，保留站解决了这个问题：

- 当指令进入保留站时，**它所需的操作数会从寄存器状态表中查找，并在写回前直接指向所需的数据源（可以是另一个保留站）**。
- 由于保留站维护指令的源操作数依赖，即便寄存器 `R1` 的值尚未写回，`I2` 依然可以等待 `I1` 的结果在保留站中的广播，避免提前读取到旧值。

因此，通过保留站和寄存器状态表的结合，寄存器的实际值和指令依赖被分离开。**保留站动态重命名了对寄存器的引用**，消除了固定的寄存器位置带来的限制，使指令可以灵活等待或使用正确的数据而不出现冲突。这种机制使得 Tomasulo 算法能够有效地避免 WAR 和 WAW 冲突。

### Tips：如何解决RAW 真数据依赖
在 Tomasulo 算法中，**RAW（Read After Write）** 冲突的处理非常重要，因为它涉及到指令之间的数据依赖性。RAW 冲突发生在一条指令试图读取一个寄存器的值，而另一条指令尚未完成对该寄存器的写入操作。在此情况下，Tomasulo 算法通过保留站和公共数据总线（CDB）来解决 RAW 问题，确保正确的数据流向指令。

#### 解决 RAW 冲突的机制

1. **保留站的作用**：
   - 每个功能单元都有多个保留站，当指令被发射到保留站时，**它将记录该指令所需的源操作数**（即将要读取的寄存器）。
   - 每条指令在进入保留站时，检查其所需的操作数是否已准备好。如果操作数的值已经可用，保留站将直接读取并使用这个值；如果操作数尚未可用，指令将继续保留在保留站中，等待操作数变得可用。

2. **寄存器状态表**：
   - 寄存器状态表用于追踪每个寄存器的最新写入状态。对于每个寄存器，寄存器状态表会记录该寄存器的最后写入来自哪个保留站。
   - 当指令需要读取寄存器的值时，它会查询寄存器状态表以了解当前的最新写入来源（即指向哪个保留站）。
   - 如果寄存器状态表中的信息显示指向一个保留站，则说明该寄存器的值尚未写回，所以指令将等待该保留站的写结果。

3. **公共数据总线（CDB）**：
   - 当执行完成后，功能单元通过公共数据总线（CDB）广播结果。所有等待该结果的指令（即依赖于此操作数的指令）会收到数据并继续执行。
   - 如果某条指令在保留站中等待某个操作数的结果，它会在接收到 CDB 广播时更新其操作数并立即继续执行。这有效地解决了 RAW 问题，因为所有依赖于这个操作数的指令能够及时获取到最新的值。

#### 处理 RAW 的步骤总结

- **发射指令**：
  - 指令被发射到保留站，检查源操作数。
  
- **检查操作数的可用性**：
  - 如果操作数可用，直接读取并存储在保留站中。
  - 如果操作数不可用，指令保持在保留站中，直到相关操作数可用。

- **依赖处理**：
  - 当操作数的写入完成时（在其他指令完成写回后），相应的保留站会通过 CDB 将数据广播到所有依赖于该操作数的保留站。

- **执行指令**：
  - 一旦所有操作数都准备好，指令就可以从保留站转发到功能单元进行执行。

#### 示例

假设我们有以下指令：

```plaintext
I1: R1 = R2 + R3
I2: R4 = R1 + R5
```

1. **发射 I1**：
   - I1 被发射到保留站，R1 的目标寄存器被记录，R2 和 R3 被检查，如果可用则读取。

2. **发射 I2**：
   - I2 被发射到保留站，但 R1 由 I1 进行写入，所以 R1 指向 I1 的保留站。
   - 由于 I1 尚未执行完毕，I2 会等待。

3. **执行 I1**：
   - I1 执行完成，并通过 CDB 将结果写回 R1。

4. **CDB 广播**：
   - I1 的结果通过 CDB 广播，保留站中任何等待 R1 的指令（如 I2）将得到这个结果。

5. **继续执行 I2**：
   - I2 现在可以获取到 R1 的最新值，并进行计算。

通过上述机制，Tomasulo 算法有效地解决了 RAW 冲突，确保了指令之间数据依赖的正确性。