### 线程初始化为何将 `ra` 设置为 `__dummy` 而不是直接设置为 `dummy`

在这段代码中，线程初始化时将 `ra`（返回地址寄存器）设置为 `__dummy`，而不是直接设置为 `dummy`。这是一种典型的线程上下文初始化的策略，目的是为了正确设置新线程的启动状态。在这种情况下，`__dummy` 的作用是桥接当前执行环境和新线程的执行环境。下面详细分析这个设计的原因和机制：

#### 1. **什么是 `ra` 和 `sepc`**
   - **`ra`**（Return Address）：通常是存储函数返回时要跳转的地址。在 RISC-V 架构中，`ra` 用于存储下一个函数调用结束时的返回地址。
   - **`sepc`**（Supervisor Exception Program Counter）：这是一个特权寄存器，在 RISC-V 中，当系统切换到用户模式或发生异常时，`sepc` 用于存储异常或切换时的程序计数器值。

#### 2. **为什么初始化时将 `ra` 设置为 `__dummy`**
   - 在初始化阶段，每个线程都会为 `ra`（返回地址寄存器）设置一个初始值，这个值决定了当线程被调度时，程序会从哪里开始执行。
   - `__dummy` 是一个专门的“入口点”，它的唯一任务就是将 `sepc` 寄存器设置为 `dummy` 函数的地址，然后通过 `sret` 指令让线程真正开始执行 `dummy`。
   - 这个设计是为了确保线程在从内核态启动时能够通过`sret`**正确从中断中退出**（因为线程切换实现在时钟中断处理中（包括恢复SIE，设置MPP等）），并开始执行 `dummy` 函数。这种模式使得线程初始化时，任务的执行流可以先经过一个中间步骤（即 `__dummy`），从而确保进入用户态的环境是正确的。


#### 3. **代码示例：`__dummy` 如何工作**
```assembly
__dummy:
    la t0, dummy            # 加载 dummy 函数的地址到 t0
    csrw sepc, t0           # 将 sepc 设置为 dummy 函数的地址
    sret                    # 从 S 模式返回，进入用户态，开始执行 dummy
```

- 这里的 `__dummy` 负责将 `sepc` 设置为 `dummy` 的地址，并通过 `sret` 进入用户态执行。这个中间步骤避免了直接跳转到 `dummy` 可能导致的特权级别混乱。

