在这个任务中，你需要为新的线程初始化一个特殊的返回函数 `__dummy`，该函数在创建新线程时会被设置为它的初始返回地址。当新线程第一次被调度时，CPU 没有任何上下文需要恢复，因此我们需要通过 `__dummy` 将程序计数器（`sepc`）指向 `dummy()` 函数，并使用 `sret` 指令从 S 模式返回，进入用户态开始执行 `dummy()`。

### 核心思路：
1. **`__dummy` 函数的功能**：
   - 它的唯一作用是在新线程的第一次调度时，将程序计数器 (`sepc`) 设置为 `dummy()` 函数的入口。
   - 通过 `sret` 指令，切换到用户态，并开始执行 `dummy()`。

2. **步骤**：
   - **设置 `sepc`**：RISC-V 的 `sepc` 寄存器是保存当前异常或中断发生时程序计数器的寄存器。我们在 `__dummy` 中将 `sepc` 设置为 `dummy()` 函数的地址。
   - **返回到用户态**：使用 `sret` 从当前的 S 模式（Supervisor 模式）返回到用户模式，正式开始执行 `dummy()` 函数。

### 实现步骤

1. **在 `arch/riscv/kernel/entry.S` 中实现 `__dummy` 函数**：
   - `__dummy` 是一个汇编函数，它要完成如下任务：
     - 将 `sepc` 寄存器设置为 `dummy()` 的地址。
     - 使用 `sret` 从 S 模式返回，进入用户态并执行 `dummy()`。

2. **汇编实现 `__dummy`**：
   - 使用 `la` 指令将 `dummy()` 的地址加载到寄存器。
   - 使用 `csrw` 指令将该地址写入到 `sepc` 寄存器中。
   - 使用 `sret` 返回。

以下是 `__dummy` 的实现代码：

```assembly
    .extern dummy           # 声明外部符号 dummy
    .globl __dummy          # 声明 __dummy 为全局函数

__dummy:
    # 将 dummy 函数的地址加载到临时寄存器 t0
    la t0, dummy            # 加载 dummy() 函数的地址到 t0
    
    # 将 t0 的值（dummy() 的地址）写入 sepc 寄存器
    csrw sepc, t0           # 将 sepc 设置为 dummy() 的地址
    
    # 使用 sret 返回，执行 dummy 函数
    sret                    # 从 S 模式返回，进入用户态，开始执行 dummy()
```

### 解释：
- **`la t0, dummy`**：将 `dummy` 函数的地址加载到寄存器 `t0` 中。
- **`csrw sepc, t0`**：将 `t0` 中保存的地址（即 `dummy()` 函数的入口地址）写入 `sepc` 寄存器。`sepc` 用于保存中断或异常发生时的返回地址，在这里我们人为设置它为 `dummy()` 的地址。
- **`sret`**：使用 `sret` 指令从 S 模式返回到用户态，并开始执行 `sepc` 中指定的地址（即 `dummy()` 函数的地址）。

### 逻辑解释：
1. 当一个新的线程首次被调度时，没有上下文可以恢复，所以我们需要手动指定其执行的第一条指令，即 `dummy()` 函数的入口地址。
2. `__dummy` 函数在新线程第一次运行时，设置好 `sepc` 为 `dummy()` 函数的地址，这样当 `sret` 返回后，CPU 将从 `dummy()` 的入口地址开始执行，模拟线程的工作。
3. `dummy()` 函数本身会不断执行，并根据线程的 `counter` 值来模拟线程运行的状态。

### 调用流程：
- 每个新线程在创建时，其返回地址会被初始化为 `__dummy`。
- 当这个线程第一次被调度时，`__dummy` 会被调用，它将 `sepc` 设置为 `dummy()` 函数的地址。
- `sret` 指令会将 CPU 从 S 模式切换回用户态，正式执行 `dummy()` 函数。

### 小结：
- 通过这个 `__dummy` 函数，线程的初始化在第一次调度时能够自动进入 `dummy()` 函数执行。
- `dummy()` 函数则是用来模拟线程运行的具体代码。在实际的系统中，类似的机制可以用来让每个新线程在首次被调度时进入它的主逻辑。