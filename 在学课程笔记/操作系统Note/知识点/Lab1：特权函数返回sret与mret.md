在RISC-V架构中，函数调用和系统返回是通过不同的机制和指令完成的。为了更好地理解这些过程，我们先分别讨论函数调用的返回方式，以及 `SRET` 和 `MRET` 指令的发生时机和作用。

### 1. 函数调用的返回
在RISC-V中，函数调用使用标准的调用约定来传递参数和返回值。以下是函数调用返回的一般过程：

- **调用函数的过程：**
  - 将返回地址保存到调用者保存的寄存器（通常是`ra`寄存器）。
  - 执行函数体。

- **函数返回的过程：**
  - 当函数执行完毕时，使用寄存器`ra`中的返回地址来跳转回调用函数的地方。这是通过`ret`指令完成的。
  - `ret`指令通常是伪指令，它实际等价于以下指令：
    ```assembly
    jalr x0, ra, 0
    ```
    这条指令会从`ra`寄存器中获取返回地址，并跳转到该地址（也就是调用函数的下一条指令），从而实现函数返回。

### 2. `SRET`和`MRET`指令

`SRET`（Supervisor Return）和`MRET`（Machine Return）是特权指令，用于在不同的特权级模式之间切换，通常用于从异常处理程序返回到上一个执行环境。

#### **`SRET`指令**
- **作用**：`SRET`用于从Supervisor（超级用户）模式返回到上一级模式（用户模式或者机器模式）。
- **发生时机**：当系统在超级用户模式下处理完某个异常、陷入、或中断时，需要使用`SRET`指令返回到之前的用户模式或中断之前的执行环境。
- **工作机制**：`SRET`指令会从`sepc`寄存器（Supervisor Exception Program Counter）中读取陷入时保存的程序计数器，并跳转到该地址，恢复到中断发生前的执行状态。此外，`SRET`指令还会恢复超级用户模式下的`SSTATUS`寄存器中保存的状态。

#### **`MRET`指令**
- **作用**：`MRET`用于从Machine（机器）模式返回到上一级模式（通常是用户模式或超级用户模式）。
- **发生时机**：当机器模式处理完某个异常、陷入、或中断时，使用`MRET`指令返回到之前的执行环境。
- **工作机制**：`MRET`指令会从`mepc`寄存器（Machine Exception Program Counter）中读取陷入时保存的程序计数器，并跳转到该地址，恢复到中断发生前的执行状态。它还会恢复机器模式下的`MSTATUS`寄存器中的状态。

### `SRET`与`MRET`的具体区别
- **执行环境不同**：
  - `SRET`在Supervisor模式下执行，用于从Supervisor模式返回到上一级模式。
  - `MRET`在Machine模式下执行，用于从Machine模式返回。

- **寄存器的使用**：
  - `SRET`依赖于`sepc`和`SSTATUS`寄存器。
  - `MRET`依赖于`mepc`和`MSTATUS`寄存器。

### 总结
- **函数调用的返回**在RISC-V架构中使用`ret`指令，通过从`ra`寄存器恢复返回地址，完成函数调用后的返回。
- **`SRET`指令**用于从超级用户模式返回到中断或陷入之前的执行环境，依赖于`sepc`和`SSTATUS`寄存器。
- **`MRET`指令**用于从机器模式返回，依赖于`mepc`和`MSTATUS`寄存器，通常发生在从异常或中断处理程序返回时。

这些指令的核心目的是在不同特权级之间切换和恢复执行环境，而普通函数调用只是在同一特权级下通过寄存器保存返回地址进行的简单跳转。