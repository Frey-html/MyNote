### 浙江大学实验报告
---
课程名称：操作系统
实验项目名称：RV64 内核线程调度
学生姓名：展翼飞  学号：3190102196
电子邮件地址：1007921963@qq.com
实验日期： 2024年 10 月 11 日

### 一、实验内容
#### 1. 准备工程
* 从lab1中拷贝lab1完成内容至lab2中，将如下宏定义添加进`defs.h` 
	![[Pasted image 20241018152902.png]]
	尝试编译，提示找不到`memset`函数定义，进行检查，发现`\lib`中除了`printk.c`均未编译，原因为makefile文件目标仅为`printk.o`，进行修改：![[Pasted image 20241018155115.png]]
	修改完成后工程正确编译

##### 1.1  `proc.h` 数据结构定义
* 阅读添加的`proc.h`，里面内置了线程状态数据结构与线程调度函数的头文件以及相关宏定义

#### 2. 线程调度功能实现
##### 2.1 线程初始化
* 在`proc.c`中按照要求步骤实现线程的初始化，包含分配物理页和初始化对应线程的 `task_struct`
	![[Pasted image 20241021095534.png]]![[Pasted image 20241021095605.png]]
	其中每个线程的`task_struct`放在物理页的起始地址，而其子结构`thread_struct`紧接着`task_struct`

##### 2.2 `__dummy` 与 `dummy` 的实现
1. `dummy`分析
	




##### 2.3 实现线程切换



##### 2.4 实现调度入口函数



##### 2.5 线程调度算法实现



#### 3. 编译及测试

### 二、思考题
1. **在 RV64 中一共有 32 个通用寄存器，为什么 `__switch_to` 中只保存了 14 个**？
2. **阅读并理解 `arch/riscv/kernel/mm.c` 代码，尝试说明 `mm_init` 函数都做了什么，以及在 `kalloc` 和 `kfree` 的时候内存是如何被管理的。**
	1. `mm_init` 
		 `mm_init`调用`kfreerange`函数，将物理内存地址从`_ekernel`到`PHY_END`的空间，按页大小遍历打包成页（起始地址需要`Roundup`到下一个页起始地址保证页对齐），并将每一页内容清空，插入空闲页链表中。
	2. `kalloc`
		  `kalloc`在空闲页链表中取出第一个空闲页并清空，返回页地址，如果空闲页链表为空则返回0.
	3. `kfree`
		 `kfree`用于释放一个 4 KiB 的物理页，首先判断传入地址是否是页对齐，如果传入的地址不是按 PGSIZE 对齐则将其`Rounddown`。然后用0清空这一页，再将该清空后的空闲页插入空闲页链表的头部。

4. **当线程第一次调用时，其 `ra` 所代表的返回点是 `__dummy`，那么在之后的线程调用中 `__switch_to` 中，`ra` 保存 / 恢复的函数返回点是什么呢？请同学用 gdb 尝试追踪一次完整的线程切换流程，并关注每一次 `ra` 的变换（需要截图）。**
5. **请尝试分析并画图说明 kernel 运行到输出第两次 `switch to [PID ...` 的时候内存中存在的全部函数帧栈布局。**
    - 可通过 gdb 调试使用 `backtrace` 等指令辅助分析，注意分析第一次时钟中断触发后的 `pc` 和 `sp` 的变化。


### 三、问题与心得






