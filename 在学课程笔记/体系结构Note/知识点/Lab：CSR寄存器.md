[RISC-V 特权级 ISA - 鹤翔万里的笔记本 (tonycrane.cc)](https://note.tonycrane.cc/cs/pl/riscv/privileged/)

在 RISC-V 架构中，**CSR**（Control and Status Register，控制状态寄存器）是用于存储和管理处理器的控制信息、状态信息的特殊寄存器。CSR 寄存器允许操作系统和用户控制、读取或改变硬件的运行状态，包括中断控制、性能计数、调试信息等。

CSR 寄存器是通过专门的**CSR 指令**（如 `csrrw`、`csrrs`、`csrrc` 等）来访问的，它们用于执行读写 CSR 寄存器的操作。

### CSR 寄存器的 12 位编码

每个 CSR 寄存器都有一个**唯一的 12 位编码**，对应一个具体的寄存器。RISC-V 定义了多个标准的 CSR 寄存器，并根据用途划分为不同类型。CSR 寄存器的编码格式为 12 位，其中最上面的两位表示访问权限，剩余的 10 位表示寄存器编号。

CSR 寄存器编码格式如下：

- **前两位**：表示访问权限。
  - `00`：只读（Read-only）。
  - `01`：用户模式可读写（User-level read/write）。
  - `10`：特权模式（Supervisor）可读写。
  - `11`：机器模式（Machine）可读写。
  
- **后 10 位**：表示寄存器编号。

例如，CSR 寄存器 `mstatus` 的编码为 `0x300`，其中：
- `0x3`（最上面两位 `11`）表示它是机器模式可读写的寄存器。
- `0x00`（低 10 位）表示寄存器编号。

### CSR 指令

CSR 指令是用于访问 CSR 寄存器的专用指令，允许程序员读取或修改 CSR 寄存器中的值。主要有三类 CSR 指令：

1. **`csrrw`（CSR Read and Write）**：读取指定的 CSR 寄存器，将它的值写入到指定寄存器，同时将一个寄存器的值写入到 CSR 寄存器中。
   
   ```assembly
   csrrw rd, csr, rs1
   ```

   - `rd`: 用来保存 CSR 寄存器的旧值。
   - `csr`: 12 位 CSR 寄存器的地址。
   - `rs1`: 要写入 CSR 寄存器的新值。

2. **`csrrs`（CSR Read and Set）**：读取 CSR 寄存器的值，将它与另一个寄存器的值按位或，然后写回 CSR 寄存器。
   
   ```assembly
   csrrs rd, csr, rs1
   ```

   - `rd`: 保存 CSR 寄存器的旧值。
   - `csr`: 12 位 CSR 寄存器的地址。
   - `rs1`: 和 CSR 寄存器的值按位或（如果 `rs1=0`，则仅读取 CSR）。

3. **`csrrc`（CSR Read and Clear）**：读取 CSR 寄存器的值，将它与另一个寄存器的值按位取反后再与 CSR 值按位与，并将结果写回 CSR 寄存器。
   
   ```assembly
   csrrc rd, csr, rs1
   ```

   - `rd`: 保存 CSR 寄存器的旧值。
   - `csr`: 12 位 CSR 寄存器的地址。
   - `rs1`: 和 CSR 寄存器的值按位清除（如果 `rs1=0`，则仅读取 CSR）。

### CSR 访问权限限制

CSR 寄存器的访问权限由其编码的前两位决定，不同权限级别的寄存器在不同的模式下有不同的访问权限：
- **用户模式**（U-mode）：只能访问用户模式允许的 CSR 寄存器（编码的最高两位为 `01`），无法访问机器模式或特权模式的寄存器。
- **特权模式**（S-mode）：可以访问用户模式和特权模式（编码最高两位为 `10`）的 CSR 寄存器，无法直接访问机器模式的 CSR 寄存器。
- **机器模式**（M-mode）：可以访问所有的 CSR 寄存器，包括机器模式、特权模式和用户模式寄存器（编码最高两位为 `11`）。

如果某个寄存器在特定权限模式下没有权限访问，尝试访问会引发非法指令异常。

### 示例：读取和修改 `mstatus` 寄存器

假设我们想要读取和修改 `mstatus`（机器状态寄存器）的值，`mstatus` 寄存器的编码是 `0x300`，它存储了机器模式下的一些重要控制状态。

#### 1. **读取 `mstatus` 的值**

使用 `csrrs` 指令读取 `mstatus` 的值：

```assembly
csrrs t0, mstatus, x0  # 读取 mstatus 的值，保存到 t0 中，x0 = 0 表示不修改 mstatus
```

- `t0` 保存 `mstatus` 寄存器的值。
- `x0` 传递给 `rs1`，因为 `x0` 的值是 0，这意味着 `mstatus` 的值不会被修改。

#### 2. **设置 `mstatus` 的某些位**

假设我们要将 `mstatus` 的某些位设置为 1，比如启用全局中断（位 3）。我们可以使用 `csrrs` 指令：

```assembly
Li t 1, 0 x 8            # 将立即数 0 x 8 加载到 t 1，表示要设置位 3
Csrrs x 0, mstatus, t 1 # 设置 mstatus 的第 3 位为 1
```

- `t 1` 中保存了要设置的位（第 3 位）。
- `csrrs` 指令将 `mstatus` 的值与 `t 1` 进行按位或操作，设置位 3。

#### 3. **清除 `mstatus` 的某些位**

如果要清除 `mstatus` 的某些位，比如禁用全局中断，可以使用 `csrrc` 指令：

```assembly
Li t 1, 0 x 8            # 加载 0 x 8，表示要清除位 3
Csrrc x 0, mstatus, t 1 # 清除 mstatus 的第 3 位
```

- `t 1` 保存要清除的位（第 3 位）。
- `csrrc` 指令将 `mstatus` 的值与 `t 1` 取反后按位与，清除对应的位。

### 总结

- **CSR 寄存器**是 RISC-V 中的控制状态寄存器，用于存储和管理硬件状态信息，每个寄存器有 12 位的唯一编码。
- CSR 指令（如 `csrrw`、`csrrs`、`csrrc`）用于读取或修改这些寄存器。
- CSR 寄存器根据权限等级限制访问，用户模式、特权模式和机器模式有不同的访问权限。


### 补充：mstatus 与 sstatus 详解

在 RISC-V 架构中，`sstatus` 和 `mstatus` 是两个关键的 **状态寄存器**，用于控制和指示处理器当前的运行状态。它们分别对应于 **S 特权级（Supervisor）** 和 **M 特权级（Machine）**，并共享一些相似的位字段。这两个寄存器用于控制中断使能、特权级切换、异常处理等操作。

下面我会详细解释 `sstatus` 和 `mstatus` 的作用、关系、各个位的含义，以及它们在处理器执行过程中的修改时机。

---

#### **1. `sstatus` 与 `mstatus` 的关系**

- **`mstatus`** 是 Machine 模式下的状态寄存器，用于控制整个处理器的核心状态。Machine 模式是 RISC-V 中最高的特权级，能够直接访问所有系统资源。
- **`sstatus`** 是 `mstatus` 的一个子集，只在 S 特权级（Supervisor 模式）下生效。它包含了一些与操作系统和内核模式相关的控制位。可以将 `sstatus` 视为 `mstatus` 中与 S 模式相关部分的镜像。

`mstatus` 包含比 `sstatus` 更多的控制位，因为它需要管理整个处理器的全局状态，而 `sstatus` 主要用于 S 模式下的中断和状态管理。

---

#### **2. `mstatus` 寄存器详解**

`mstatus`（Machine Status Register）是 RISC-V 中最高特权级别的控制寄存器。它包含多个控制位，决定了处理器的行为，尤其是在特权模式之间的切换和中断处理中。以下是 `mstatus` 中常见位的详细说明：

| 位   | 名称       | 含义                                                |
| --- | -------- | ------------------------------------------------- |
| 0   | **UIE**  | 用户模式中断使能标志，控制用户模式中断的全局使能状态。                       |
| 1   | **SIE**  | S 模式全局中断使能。                                       |
| 3   | **MIE**  | M 模式全局中断使能                                        |
| 4   | **UPIE** | 在用户模式时保存的中断使能状态（当进入更高模式时）。                        |
| 5   | **SPIE** | 保存的前一个 S 模式全局中断使能（在进入 M 模式或处理异常时）。                |
| 7   | **MPIE** | 保存的前一个 M 模式全局中断使能                                 |
| 8   | **SPP**  | S 模式中断处理前的特权级别（0 = U，1 = S）。                      |
| 11  | **MPP**  | M 模式中断处理前的特权级别：00（用户模式），01（保留），10（S 模式），11（M 模式）。 |
| 12  | **FS**   | 浮点状态标志：表示浮点寄存器是否被使用。                              |
| 13  | **XS**   | 扩展状态标志：扩展寄存器使用情况。                                 |
| 15  | **MPRV** | M 模式下的加载和存储权限控制。                                  |
| 17  | **SUM**  | S 模式下，允许用户页面访问。                                   |
| 18  | **MXR**  | 允许 S 模式加载执行权限的页面。                                 |
| 19  | **TVM**  | 禁用虚拟内存管理（仅对 S 模式有效）。                              |
| 20  | **TW**   | 禁止 S 模式下的 `wfi` 指令。                               |
| 21  | **TSR**  | 禁止 S 模式修改 `sstatus.SIE`。                          |
| 23  | **SD**   | 系统脏状态位，表示浮点或扩展状态寄存器是否脏。                           |

##### **关键位解释：**

- **UIE, SIE, MIE（位 0, 1, 3）**：这些是全局中断使能位，用于控制不同模式下的中断使能。`MIE` 控制 M 模式的中断使能，`SIE` 控制 S 模式中断使能，`UIE` 控制 U 模式中断使能。

- **UPIE, SPIE, MPIE（位 4, 5, 7）**：这些是保存中断使能的前状态位，用于在进入中断或异常时，保存当前模式的中断状态，以便在返回时恢复。

- **SPP（位 8）**：保存 S 模式下的前一个特权级。当进入 M 模式时，该位会保存 S 模式下的前一个特权级，以便返回时恢复。

- **MPP（位 11）**：保存机器模式进入时的前一个特权级。值为 `00` 表示用户模式，`01` 保留，`10` 表示 S 模式，`11` 表示 M 模式。

- **FS（位 12）**：浮点寄存器状态，指示浮点寄存器是否已保存或需要保存。它有 4 个状态：关闭（Off）、初始（Initial）、干净（Clean）、脏（Dirty）。

- **MPRV（位 15）**：在 M 模式下，允许内存访问使用当前特权模式，而不是 M 模式的访问权限。

- **SUM（位 17）**：控制 S 模式是否允许访问用户模式的内存页面。设置该位可以允许 S 模式访问用户模式的内存。

- **MXR（位 18）**：允许 S 模式加载可执行权限的页面。这是为实现某些特殊权限管理需求而设计的。

- **SD（位 23）**：指示系统中是否有任何扩展或浮点寄存器被修改（即"脏"状态）。如果系统中有脏的浮点或扩展寄存器，`SD` 位将被设置。

---

#### **3. `sstatus` 寄存器详解**

`**sstatus**`（Supervisor Status Register）是 S 模式下的状态寄存器，是 `mstatus` 的一个子集。它包含了一些与操作系统内核相关的控制位。以下是 `sstatus` 中的关键位解释：

| 位     | 名称           | 含义                                                                 |
|--------|----------------|----------------------------------------------------------------------|
| 1      | **SIE**         | S 模式全局中断使能。                                                  |
| 5      | **SPIE**        | S 模式中断使能的前一状态，在陷入异常时保存 SIE 的状态。                   |
| 8      | **SPP**         | 保存 S 模式的前一个特权级（0 = 用户模式，1 = S 模式）。                 |
| 12     | **FS**          | 浮点寄存器状态。                                                      |
| 13     | **XS**          | 扩展状态寄存器状态。                                                  |
| 17     | **SUM**         | 控制 S 模式是否可以访问用户模式的内存页面。                             |
| 18     | **MXR**         | 允许 S 模式加载可执行权限的页面。                                      |
| 23     | **SD**          | 系统是否有脏的扩展寄存器或浮点寄存器。                                 |

##### **关键位解释：**

- **SIE（位 1）**：这是 S 模式下的全局中断使能位。如果设置为 1，S 模式允许中断；如果为 0，则禁用中断。

- **SPIE（位 5）**：在陷入中断或异常时，该位保存了 SIE 的前一状态。当异常处理结束返回时，该位会被恢复到 SIE。

- **SPP（位 8）**：在陷入异常时保存 S 模式的前一个特权级（0 = 用户模式，1 = S 模式）。在异常返回时，该位用于决定恢复到哪个特权级。

- **FS（位 12）**：与 `mstatus` 类似，控制浮点寄存器的使用情况。

- **SUM（位 17）**：当设置时，S 模式允许访问用户模式的内存页面。这在某些操作系统内存访问权限管理中非常有用。

- **MXR（位 18）**：与 `mstatus` 类似，允许 S 模式加载执行权限的页面。

- **SD（位 23）**：指示浮点寄存器或扩展寄存器是否被修改（脏）。

---

#### 总结

- `mstatus` 和 `sstatus` 都是 RISC-V 的状态寄存器，分别用于机器模式和超级模式下的状态管理。
- **`sstatus`** 是超级模式下的状态寄存器，控制超级模式的中断、特权级、浮点状态等信息。
- **`mstatus`** 是机器模式下的状态寄存器，控制机器模式的中断、特权级、浮点状态等信息。
- 状态寄存器的位在特权级切换、上下文切换、异常处理等过程中会被相应地修改和保存，以确保状态一致性和正确性。


### 补充 2：mstatus 与 sstatus 关系
在 RISC-V 架构中，`mstatus` 和 `sstatus` 寄存器并不共享一个寄存器。它们各自独立，但在某些方面是相互关联的，尤其是在特权级切换时。下面详细解释这两个寄存器之间的关系以及它们的高位的意义。

#### 1. 独立的寄存器

- **`mstatus`**（机器状态寄存器）和 **`sstatus`**（超级状态寄存器）是两个独立的寄存器，各自具有不同的位和功能。它们分别用于不同的特权级。
- 在 RISC-V 中，机器模式（Machine Mode）是最高特权级，超级模式（Supervisor Mode）是中间特权级，用户模式（User Mode）是最低特权级。

#### 2. 状态寄存器的结构

- **`mstatus`** 寄存器包含多个用于控制机器模式下的状态信息的位。
- **`sstatus`** 寄存器包含多个用于控制超级模式下的状态信息的位。

#### 3. 位的含义

- **有效位**：这两个寄存器的低位（如 `UIE`、`SIE`、`MIE` 等）都是有效的，表示中断使能、特权级、浮点状态等功能。
- **高位**：在这两个寄存器中，通常存在一些高位，但它们可能并不总是有效，具体取决于实现和使用的特权级。

#### 4. 高位的作用

- **高位的意义**：
  - 高位可能用于保留、扩展或未来的特性。RISC-V 架构设计时可能会预留某些位以便将来扩展。
  - 在某些实现中，可能会将高位用于特定的实现特性，但这些特性并不是 RISC-V 规范的一部分。
  
- **一般来说**，在实际使用中，用户不会直接修改高位，这些位主要是系统保留的，确保寄存器的对齐和扩展性。

#### 5. 切换和复制机制

- 当进入超级模式时，系统会从 `mstatus` 复制特定的状态信息到 `sstatus`。这可以理解为在切换特权级时，部分信息的传递。
- 从超级模式返回到机器模式时，`sstatus` 中的某些状态信息将被写回 `mstatus`。

#### 总结

- **`mstatus`** 和 **`sstatus`** 是独立的状态寄存器，分别用于机器模式和超级模式。
- 它们的位分别控制各自特权级的状态，并且有可能存在一些无效或保留的高位。
- 在特权级之间切换时，状态寄存器中的某些信息会被复制和更新，但它们是独立的实体，不是共享的寄存器。

### 补充 3：mstatus，sstatus读写权限
在 RISC-V 架构中，`mstatus` 和 `sstatus` 寄存器的读写权限如下：

#### 1. `mstatus` 寄存器

- **读权限**：
  - 任何特权级（M-mode、S-mode 和 U-mode）都可以读取 `mstatus` 寄存器的值。
  
- **写权限**：
  - 只有在 **M-mode**（机器模式）下，才能写入 `mstatus` 寄存器。用户模式（U-mode）和超级模式（S-mode）不能直接修改 `mstatus` 的内容。

#### 2. `sstatus` 寄存器

- **读权限**：
  - 任何特权级（M-mode 和 S-mode）都可以读取 `sstatus` 寄存器的值。
  
- **写权限**：
  - 只有在 **S-mode**（超级模式）下，才能写入 `sstatus` 寄存器。用户模式（U-mode）不能直接修改 `sstatus` 的内容。

#### 访问权限总结

| 寄存器    | 读权限          | 写权限          |
|-----------|------------------|------------------|
| `mstatus` | M-mode、S-mode、U-mode | 仅 M-mode         |
| `sstatus` | M-mode、S-mode   | 仅 S-mode        |

#### 权限机制的作用

- **`mstatus` 寄存器**: 用于全局控制和状态，影响整个系统的行为，因此需要在最高特权级别下进行写入，确保安全性。
  
- **`sstatus` 寄存器**: 主要用于超级模式下的状态管理，允许操作系统在处理系统调用或中断时更新相关状态。

#### 示例

以下是如何在 RISC-V 汇编中使用 `mstatus` 和 `sstatus` 的示例：

```assembly
# 读取 mstatus 到寄存器 x1
csrr x1, mstatus          # 任何模式都可以读取

# 仅在 M-mode 下可以修改 mstatus
csrw mstatus, x2          # 仅在 M-mode 下有效

# 读取 sstatus 到寄存器 x3
csrr x3, sstatus          # M-mode 和 S-mode 都可以读取

# 仅在 S-mode 下可以修改 sstatus
csrw sstatus, x4          # 仅在 S-mode 下有效
```

#### 总结

- `mstatus` 寄存器可以在所有模式下读取，但只能在 M-mode 下写入。
- `sstatus` 寄存器可以在 M-mode 和 S-mode 下读取，但只能在 S-mode 下写入。
  
这种设计确保了系统的安全性和稳定性，同时允许在不同特权级别下进行适当的操作。