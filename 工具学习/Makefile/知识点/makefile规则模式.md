在 `Makefile` 中，**规则模式**（Pattern Rules）是一种通用的规则定义方式，用于处理具有相似命名结构的多个文件。它利用通配符（如 `%`）来表示文件名的通用部分，使你能够为一类文件定义通用的构建规则，而无需为每个文件编写单独的规则。

### 规则模式的基本语法

规则模式的格式与普通的 Makefile 规则类似，但它使用 `%` 来匹配文件名的通用部分：

```makefile
TARGET_PATTERN: DEPENDENCY_PATTERN
    COMMAND
```

- **`TARGET_PATTERN`**：目标文件的模式，`%` 用于匹配文件名中任意部分。例如，`%.o` 表示任意 `.o` 文件。
- **`DEPENDENCY_PATTERN`**：依赖文件的模式，`%` 对应目标文件中的相同部分。例如，`%.c` 表示与目标 `.o` 文件同名的 `.c` 文件。
- **`COMMAND`**：生成目标文件的命令。

#### 示例 1：从 `.c` 文件生成 `.o` 文件

这是最常见的规则模式，用于从 `.c` 文件编译生成 `.o` 文件：

```makefile
%.o: %.c
    $(CC) -c $(CFLAGS) $< -o $@
```

- **`%.o`**：匹配所有 `.o` 文件的目标。例如，当目标是 `foo.o` 时，`%` 对应的是 `foo`。
- **`%.c`**：匹配与 `.o` 文件同名的 `.c` 文件。例如，生成 `foo.o` 的依赖是 `foo.c`。
- **`$<`**：第一个依赖文件（即 `.c` 文件）。
- **`$@`**：当前的目标文件（即 `.o` 文件）。

#### 实际效果

当 `make` 碰到目标 `foo.o` 时，它会匹配这条规则，然后执行以下命令：

```bash
gcc -c $(CFLAGS) foo.c -o foo.o
```

同理，遇到 `bar.o` 时，则会执行：

```bash
gcc -c $(CFLAGS) bar.c -o bar.o
```

### 为什么使用规则模式？

1. **减少重复代码**：对于一类文件（例如所有 `.o` 文件），你可以通过模式规则只写一条通用规则，而不必为每个 `.o` 文件手动编写单独的规则。
   
2. **自动推导依赖关系**：`make` 可以自动根据文件的扩展名推导出依赖关系。例如，它会自动知道要从 `foo.o` 生成目标时，应该依赖 `foo.c`。

3. **灵活性**：可以根据文件名结构灵活匹配不同的文件。除了常见的 `.c` 到 `.o`，还可以为其他文件类型创建规则模式。

### `make` 自动推导规则

`make` 有一些**内置的模式规则**。例如，`make` 内置了从 `.c` 到 `.o` 的规则：

```makefile
%.o: %.c
    $(CC) -c $(CFLAGS) $< -o $@
```

所以在很多情况下，你不需要在 Makefile 中显式写出这条规则，因为 `make` 会自动知道如何从 `.c` 文件生成 `.o` 文件。

### 更复杂的规则模式

规则模式不仅仅局限于简单的 `.o` 和 `.c` 之间的映射，还可以用于更复杂的依赖关系。

#### 示例 2：从 `.c` 文件生成可执行文件

假设你想直接从 `.c` 文件生成可执行文件：

```makefile
%: %.c
    $(CC) $(CFLAGS) $< -o $@
```

- **`%`**：表示所有文件，匹配目标是没有后缀的可执行文件。
- **`%.c`**：表示与目标同名的 `.c` 文件。
- **`$<`**：表示依赖的 `.c` 文件。
- **`$@`**：表示生成的可执行文件。

#### 实际效果

如果你有一个 `hello.c` 文件，并且想生成可执行文件 `hello`，则执行以下命令：

```bash
gcc $(CFLAGS) hello.c -o hello
```

### 复杂依赖关系示例

#### 示例 3：从 `.c` 文件生成 `.o` 文件，同时依赖于多个头文件

有时候，目标文件可能依赖于多个源文件或头文件：

```makefile
%.o: %.c %.h common.h
    $(CC) -c $(CFLAGS) $< -o $@
```

- 这个规则表示，生成 `foo.o` 不仅需要 `foo.c`，还需要 `foo.h` 和 `common.h`。
- 如果任何一个依赖文件（如 `foo.c`、`foo.h` 或 `common.h`）被修改，`make` 都会重新编译 `foo.o`。

### 常见的模式规则与自动变量

| 自动变量 | 含义                                            |
| -------- | ----------------------------------------------- |
| `$@`     | 当前的目标文件                                  |
| `$<`     | 第一个依赖文件（在依赖列表中的第一个文件）      |
| `$^`     | 所有依赖文件（空格分隔）                        |
| `$?`     | 所有比目标文件更新的依赖文件                    |
| `$*`     | 匹配 `%` 的部分，适用于模式规则中               |

#### 示例 4：链接多个 `.o` 文件生成可执行文件

```makefile
prog: foo.o bar.o
    $(CC) $^ -o $@
```

- **`prog`**：目标是生成 `prog` 可执行文件。
- **`$^`**：所有的依赖文件（即 `foo.o bar.o`）。
- **`$@`**：目标文件（即 `prog`）。

`make` 会执行以下命令：

```bash
gcc foo.o bar.o -o prog
```

### 模式规则与显式规则的结合

可以将模式规则与显式规则结合使用，以确保 `make` 正确处理依赖关系。例如：

```makefile
all: prog

prog: foo.o bar.o
    $(CC) $^ -o $@

%.o: %.c
    $(CC) -c $(CFLAGS) $< -o $@

clean:
    rm -f *.o prog
```

- 目标 `all` 依赖于 `prog`。
- `prog` 依赖于 `foo.o` 和 `bar.o`，它们又通过模式规则从 `foo.c` 和 `bar.c` 编译。
- `clean` 是一个伪目标，用于清除编译生成的文件。

### 总结

- **规则模式**通过使用 `%` 来匹配文件名的通用部分，允许你为一类文件定义通用的构建规则，减少重复代码。
- 常见的规则模式包括从 `.c` 文件生成 `.o` 文件或从 `.o` 文件链接生成可执行文件。
- 规则模式可以通过自动变量（如 `$@`、`$<`）来简化编译命令的编写。
