
常量指针和指针常量的写法与 `*` 运算符的结合顺序以及 C++ 中的声明规则有关
[C++运算符优先级_c++语言 >和+优先级-CSDN博客](https://blog.csdn.net/nicky_zs/article/details/4053146)
[常量指针和指针常量的区别_指针常量和常量指针-CSDN博客](https://blog.csdn.net/weibo_dm/article/details/80445205)
### 1. 声明顺序与结合性

在 C++ 中，指针的声明由类型、修饰符和指针符号（`*`）组成。在这条规则中，**修饰符的顺序**决定了指针的特性（即它是常量指针还是指针常量）。

#### **结合性**

- 在 C++ 中，`*` 运算符的结合顺序是从右到左。也就是说，声明中的指针符号与其后面的类型组合在一起，形成一个完整的类型。

### 2. 常量指针 (`const T*`)

- **语法**: `const T* p;`
  - 这里，`const` 修饰的是 `T`（即所指向的类型），表示指针 `p` 指向的内容是常量。你不能通过 `p` 修改所指向的值，但可以修改 `p` 指向的地址。

- **结合性**:
  - 由于 `const` 在 `*` 的左边，因此它作用于指针所指向的类型 `T`，而不是指针 `p`。

### 3. 指针常量 (`T* const`)

- **语法**: `T* const p;`
  - 在这种情况下，`const` 修饰的是指针 `p` 本身，表示 `p` 的地址是常量。你可以修改 `p` 所指向的内容，但不能修改 `p` 的地址。

- **结合性**:
  - 由于 `const` 在 `*` 的右边，因此它作用于指针 `p`，而不是指针所指向的类型 `T`。

### 4. 示例分析

让我们来看一个具体的示例，以说明这个结合顺序如何影响指针的声明。

```cpp
#include <iostream>

int main() {
    int x = 5;
    const int* p1 = &x; // 常量指针，指向常量 int
    int* const p2 = &x;       // 指针常量，指向 int

    // 下面的操作
    // *p1 = 10; // 错误：不能修改 p1 指向的内容
    p1 = nullptr; // 合法：可以改变 p1 的指向

    *p2 = 10; // 合法：可以通过 p2 修改 x 的值
    // p2 = nullptr; // 错误：不能改变 p2 的指向

    std::cout << "x: " << x << std::endl; // 输出 x 的值

    return 0;
}
```

### 5. 小结

- **结合性**: 
  - `const T* p;` 中，`const` 修饰的是 `T`，意味着 `p` 是一个常量指针（指向常量）。
  - `T* const p;` 中，`const` 修饰的是指针 `p`，意味着 `p` 是一个指针常量（指向可以修改的内容）。

- **顺序与写法**: 
  - 常量指针和指针常量的声明方式是由语言的语法规则决定的，而不是随意选择的。
  
- **阅读技巧**: 
  - 从右到左理解声明的顺序是一个有效的技巧：`const` 出现在 `*` 的前面，指向的内容是常量；而 `const` 出现在 `*` 的后面，指针本身是常量。

通过理解这些基本概念和结合性，你可以更清晰地编写和阅读 C++ 中的指针声明。