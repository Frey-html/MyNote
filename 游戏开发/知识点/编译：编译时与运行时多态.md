**函数模板**是 **编译时多态** 的一种形式。要理解这点，首先我们需要理解什么是**多态**，以及函数模板如何实现**编译时多态**。

### 什么是多态？

**多态**（Polymorphism）是面向对象编程中的一个核心概念，指的是同一操作在不同对象上有不同表现形式的能力。多态主要分为两类：

1. **编译时多态**（静态多态）：在编译阶段决定函数调用的类型。
2. **运行时多态**（动态多态）：在程序运行时决定函数调用的类型。

#### 编译时多态
编译时多态（也叫静态多态）是指程序在编译时就已经确定了函数或操作符的类型或行为。常见的编译时多态的实现方式包括：
- **函数重载**：同名函数，但参数类型或数量不同，编译时根据传递的参数类型来选择调用哪个函数。
- **模板**：包括**函数模板**和**类模板**，在编译时生成具体类型的代码。

#### 运行时多态
运行时多态是通过**虚函数**和**继承**来实现的，它在运行时根据实际的对象类型决定调用哪个函数。使用了动态绑定（如通过虚表 `vtable`），在程序运行时进行类型匹配。
- 主要特征是**继承**和**虚函数**。

### 函数模板与编译时多态

**函数模板**是 **C++** 中的一种编译时多态，它允许编写泛型代码，使得同一函数能够处理不同的数据类型。在编译时，编译器根据具体调用时传递的类型参数，生成不同类型的函数实例。

#### 函数模板的工作原理：
当你定义一个函数模板时，模板只是一个泛型的代码结构，并不代表具体的函数。只有在你调用模板函数时，编译器根据传递的参数类型生成对应的具体函数，这个过程被称为**模板实例化**。

例如，下面是一个简单的函数模板：
```cpp
template<typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}
```

当你调用 `max(3, 5)` 时，编译器会根据传递的参数类型（`int`），自动生成一个 `int` 类型的 `max` 函数：
```cpp
int max(int a, int b) {
    return (a > b) ? a : b;
}
```

如果你调用 `max(3.2, 4.5)`，编译器则会生成一个 `double` 类型的 `max` 函数。

- **编译时多态**：函数模板的具体类型是在**编译时**根据调用的参数类型确定的。不同类型的调用，编译器会生成不同的函数代码。调用 `max<int>()` 和 `max<double>()` 会生成不同的实例，而这个过程发生在编译期，不涉及运行时的类型检查或选择。
  
因此，函数模板被称为 **编译时多态**，因为在编译阶段就确定了函数的具体类型，并且不同类型的实例在编译时生成对应的代码。

### 编译时多态 vs 运行时多态

1. **编译时多态（静态多态）**：
   - 通过模板和函数重载实现。
   - 类型和行为在编译时决定。
   - 没有运行时开销。
   - 没有虚函数表（`vtable`）或指针开销。
   - 例子：函数模板、类模板、函数重载、运算符重载。

2. **运行时多态（动态多态）**：
   - 通过继承和虚函数实现。
   - 类型和行为在运行时根据对象的实际类型决定。
   - 有运行时开销（例如虚表查找）。
   - 通过基类指针或引用来调用子类的重写函数。
   - 例子：虚函数、纯虚函数、继承。

### 函数模板和多态的对比

- **函数模板**通过类型参数的泛型实现编译时多态，这允许代码的高效重用，并在编译阶段实例化具体类型的函数。
  
- **运行时多态**通过虚函数实现，通常用于处理**继承层次中的对象多态性**。在运行时根据实际对象的类型来决定函数的调用，这在某些情况下更加灵活，但会带来运行时开销。

### 总结
- **函数模板是编译时多态**，因为模板实例化发生在编译阶段，编译器会生成适用于不同类型的代码，而不需要在运行时进行类型判断。
- **多态** 是指同一操作可以根据对象或类型的不同表现出不同的行为，它分为**编译时多态**（如函数模板、函数重载）和**运行时多态**（如虚函数）。

