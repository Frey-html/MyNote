* 参考文档
	[C# 文档 - 入门、教程、参考。 | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/csharp/)
	[C#核心-唐老师](https://www.bilibili.com/video/BV1tV411q7Rq/?p=21&spm_id_from=pageDriver&vd_source=8636d68797fa4651942df4dc09db7987)

#### 类型系统
* C#是一种强类型语言。每个变量和常量都有一个类型，每个求值的表达式也是如此。每个方法声明都为每个输入参数和返回值指定名称、类型和种类（值、引用或输出）。编译器**将类型信息作为元数据嵌入可执行文件中**。 公共语言运行时 (CLR) 在运行时使用元数据，以在分配和回收内存时进一步保证类型安全性。

### C#基础
#### 复杂数据类型
##### 枚举
* 被命名的整型常量的集合，一般用来表示状态和类型![[Pasted image 20221215125338.png]]
* 在哪里声明枚举？
	* namespace语句块中，也可以在class和struct中
	* 不能在函数语句块中声明
* 枚举类型转换
	* 可以使用强制类型转换和int转换
	* ToString是把枚举项的名字转换成string
	* 把string转换成枚举：Enum.Parse然后强转成枚举类型

##### 一维数组
* 声明： 变量类型[] 数组名; 可以是任意变量类型![[Pasted image 20221215130309.png]]
* 使用
	* 长度 Length属性
	* 修改：下标索引 不能越界，运行时报错
* 增加或删除数组元素：搬家
* 查找数组元素：遍历

#### 函数
##### ref和out
* ref和out可以在函数内部改变外部传入的内容，使值类型在函数栈可以更改外部的值，引用类型可以在函数栈更改带动外部指向其他（相当于传指针和C++传引用）
* 使用：在函数声明和使用时在参数前加关键字ref或out
* ref和out区别
	* ref传入的变量必须初始化，out不用
	* out传入的变量必须在内部赋值，ref不用

##### 变长参数和参数默认值
* 变长参数：params用于修饰数组，传入任意个参数到数组中，数组类型可以是任意的![[Pasted image 20221215135709.png]]
	* 函数参数可以有别的参数和params关键字修饰的参数
	* 函数参数最多出现一个params关键字，并且一定是在最后一个参数上
* 函数默认值：
	* 支持多参数默认值，每个参数都可以由默认值
	* 如果要混用无默认值的有默认值参数，可选参数必须写在普通参数后


### 面向对象
#### 封装
##### 成员属性
* 基础概念
	* 用于保护成员变量
	* 为成员属性的获取和赋值添加逻辑处理
	* 解决3P访问限制的局限性 public private protected（只限制访问，不能够做到限制只获取不能修改）
* 基本语法
	![[Pasted image 20221214144616.png]]
	get：这个属性可以获取的内容，使用return返回，可以在返回之前添加一些逻辑规则
	set：value关键字表示从外部传入的值，类型与声明的属性类型一致
	加密解密处理：最基础为使用属性存取时加减一个固定值，实现存储的值的加密
* 访问修饰符
	* get和set前可以加访问修饰符
	* 默认不加会使用属性声明时的访问权限
	* 加的访问修饰符要低于属性的访问权限
	* 不能让get和set的访问权限都低于属性的访问权限
* get和set可以只有一个
	* 只有一个时不需要在get或set前加访问修饰符
	* 一般情况下只会有只有get的情况
* 自动属性
	* 作用：外部能得不能改的特征
	* 如果类中有一个特征是只希望外部能得不能改，又无特殊处理，那么可以直接使用自动属性（如果能得能改或者不能的不能改可以直接使用public或private）![[Pasted image 20221214150239.png]]

##### 索引器
* 让对象可以向数组一样可以通过索引访问其中元素，让程序看起来更直观更容易编写
* 索引器语法![[Pasted image 20221214153723.png]]
* 索引器可以重载：参数类型、数量、顺序不同

##### 静态成员
* 使用static修饰，通过类名直接点出
* 程序开开始运行时，就会为静态成员分配内存，知道程序结束空间被释放
* 静态函数不能使用非静态成员：静态成员是独立于对象存在的，非静态函数可以使用静态成员
* 作用：
	* 静态变量：
		* 声明常用的唯一的变量
		* 声明方便别人获取的对象
* 静态内容不会被垃圾回收，如果静态变量占用空间太多，则可以**动态分配的空间会变少**，频繁地触发垃圾回收导致程序卡顿
* 常量和静态变量：
	* const是可理解为特殊的静态
	* const必须初始化不能修改
	* const只能修饰变量，static可以修饰方法，属性等
	* const一定要写在访问修饰符后面，static不必

##### 静态类和静态构造函数
* 静态类特点
	* 只能包含静态成员
	* 不能被实例化
* 作用
	* 将常用的静态成员写在静态类中方便使用
	* 静态类不能被实例化，更能体现工具类的唯一性
	比如Console就是一个静态类
* 静态构造函数
	在构造函数前加static修饰
	* 特点
		* 静态类和普通类都可以有
		* 不能使用访问修饰符
		* 不能有参数
		* 只会自动调用一次，在第一次使用类成员时自动调用
	* 作用：
		* 在静态构造函数中初始化静态变量

##### 拓展方法
* 为现有的**非静态**变量类型**添加新方法**
	* 提升程序拓展性
	* 不需要在原有的类中重新写方法
	* 不需要继承来添加新方法
	* 为别人封装的类型写额外的方法
* 特点
	* 一定是写在静态类中
	* 一定是个静态函数
	* 第一个参数为拓展目标，用this修饰
* 基本语法：写在静态类中![[Pasted image 20221214212549.png]]


#### 继承
##### 万物之父 object
* object是所有类型的基类
	* 可以利用里氏替换原则，用object作为容器装所有对象
	* 可以表示不确定类型，作为函数参数类型
* 装箱与拆箱
	* 装箱：值类型用引用类型存储，栈内存迁移到堆内存
	* 拆箱：把引用类型存储的值类型取出来，堆内存迁移到栈内存
	* 好处：不确定类型时可以方便参数的存储和传递
	* 坏处：存在内存迁移，增加内存消耗
#### 多态
##### 多态基础
* 多态：继承同一弗雷德子类，在执行相同方法有不同表现，让同一对象有唯一行为的特征(父类装子类时）
* 函数的重载也类似多态，是编译时区分的

* 运行时的多态：VOB
	* vitrual：虚函数，能够被子类重写
	* override：重写虚函数（与通过new覆盖父类方法不同，重写虚函数能够在父类装子类时直接调用到子类的相应虚函数而不需要as转换）
	* base:父类，可通过base调用父类函数，保留父类行为

##### 抽象类与抽象方法
* 抽象类：用abstract修饰的类 （即C++纯虚类）
	* 不能被实例化
	* 可以包含抽象方法
	* 继承抽象类必须重写其抽象方法

* 抽象方法（纯虚方法）
	* 用abstract修饰的方法
	* 只能在抽象类中声明
	* 没有方法体
	* 不能是私有的
	* 继承后必须实现，用override重写
	* **与虚方法区别**
		* 虚方法可以选择性实现，抽象方法必须实现
		* 虚方法有函数体，抽象方法没有

##### 接口
* 接口是**行为**的抽象规范
* 接口声明的规范
	* 不包含成员变量
	* 只包含方法、属性、索引器、事件
	* 成员不能被实现
	* 成员可以不用写访问修饰符，不能是私有的
	* 接口不能继承类，但可以继承一个或多个接口
* 接口使用规范
	* 类可以继承多个接口
	* 类继承接口后，必须实现接口的所有成员
* 特点
	* 它和类的声明类似
	* 接口是用来继承的
	* 接口不能被实例化，但可以**作为容器存储对象**
* 接口的使用
	* 类可以继承1个类，多个接口
	* 类继承了接口后，必须实现其中内容，并且**必须是public**
	* 实现的接口函数，可以是虚函数，以被子类重写
	* 接口遵循里氏替换原则，可以用接口对象装实现接口的类
* 显示实现接口
	当一个类继承两个接口但其中存在同名方法时，为了实现两个不同的同名方法，使两个父类装子类调用该方法时有不同表现，在类中实现接口方法可以加上接口名![[Pasted image 20221214213757.png]]
	但此时直接用该类不能直接获得该方法，只能父类装子类或者使用as（除非多写一个自己的同名方法，用该类对象调用的也是自己的同名方法）

#### 面向对象关联知识点
##### 万物之父object
* object静态方法
	* Equals方法 判断两个对象是否相等，不管值类型引用类型都会按照**左侧对象的Equals方法**来进行比较
	* ReferenceEquals 比较两个对象是否是相同引用，值类型返回值始终是false
* object成员方法
	* **GetType** 获取对象运行时的类型Type，是与反射相关的重要方法，返回类型为Type类对象
	* MemberwiseClone 获取对象的浅拷贝对象（新对象的引用变量回合老对象中的一致）
* object中的虚方法
	* Equals **默认实现**还是比较两者是否为同一引用，即相当于ReferenceEquals，然而微软在所有值类型的基类System.ValueType中重写了该方法来比较值相等，我们也可以重写该方法自定义比较像等规则
	* GetHashCode 获取对象哈希值，可以重写自定义对象的哈希码算法
	* ToString 返回**当前对象代表的字符串**，可以自定义我们对象转字符串的规则（WriteLine自动调用对象的ToString方法）
##### String
* **关于string的存储和修改**：字符串对象创建时会在内存中创建字符串常量（会查询该字符串是否已存在），string赋值即是指向该字符串地址，string中改变字符串的方法一般均不会改变原有的字符串，而是在堆中创建新的修改过的字符串，返回一个新的string对象，**每一次重新赋值或拼接都会需要新的空间，string经常修改会很浪费空间**
* 字符串指定位置的获取
	* 索引器：string类是字符数组的封装，设置了索引器，可以通过中括号获取
	* 转为char数组： ToCharArray方法
* 字符串拼接 Format静态方法![[Pasted image 20221215010832.png]]
* 正向查找字符位置 IndexOf方法，没找到返回-1
* 反向查找字符位置 LastIndexOf方法
* 移除指定位置后字符串 Remove
	* 单参数i 返回从位置i移除后的新字符串对象，包含位置i
	* 双参数i j 开始位置和字符个数
* 替换指定字符串 Replace方法 返回新的string对象
* 大小写转换 ToUpper ToLower
* 字符串截取从指定位置之后的字符串 SubString
	* 单参数：从i开始
	* 双参数：从i开始，截取j个
	* 不会自动判断越界
* **字符串切割** Split
	参数为切割符，返回切割后的字符串数组![[Pasted image 20221215012318.png]]
	可用于游戏开发读取数据

##### StringBuilder
* 修改字符串时重新创建新的字符串，需要频繁修改可以使用，使用前需要引用命名空间System.Text
* 容量：
	StringBuilder存在容量，每次往里面增加不超过容量时不需要分配新的空间，超过容量时会自动扩容然后搬到新的空间（不需要扩容时不会产生垃圾，比string产生更少的垃圾）
	* 默认容量16个char（C#字符存储编码为UTF-16,为32bytes），每次自动扩容翻倍
	* 获得容量：Capacity属性 声明时可设置最大容量
	* 获得字符长度: Length属性
* 增删查改
	* 增加：
		* Append()方法
		* AppendFormart()方法，可增加格式化字符串
	* 插入：
		* Insert()方法 位置和字符串
	* 删：
		* Remove()方法 开始位置和长度
	* 查：直接使用索引器
	* 改：使用索引器直接修改
	* 替换：
		* Replace()方法 直接在内存修改，不会产生新字符串
	* 重新赋值：
		* 清空Clear()加增加Append()
	* 判断相等：
		* Equals()方法
* **和String比较：** 更少频率的垃圾回收，但方法少于string（比如没有IndexOf）

##### 结构体和类的区别
* 结构体和类最大的区别时存储空间上的，结构体是值类型存储在栈上，类是引用类型存储在堆上
* 结构体和类使用上很类似，结构体具备封装特性，但是不具备继承和多态，结构体不能使用protected访问修饰符
* 结构体变量声明不能指定初始值，而类可以
* 结构体不能声明无参构造函数，而类可以
* 结构体声明有参构造函数后，默认无参构造不会被顶掉
* 结构体不能声明析构函数，而类可以
* 结构体需要在构造函数中初始化所有成员变量，而类随意
* 结构体本身不能被static修饰，而类可以有静态类
* 结构体不能在内部声明和自己一样的结构体变量，而类可以

特别之处：
* 结构体可以继承接口，因为接口是行为的抽象

**如何选择结构体：**
* 如果使用继承和多态，如玩家，怪物，淘汰结构体
* 对象是数据集合时，优先考虑结构体，如位置，坐标
* 从值类型和引用类型赋值区别考虑，如果经常被复制传递且原对象不想随之变化时，用结构体，比如坐标，向量，旋转

##### 抽象类和结构区别
![[Pasted image 20221215120955.png]]

* 相同点：
	* 都可以被继承
	* 都不能实例化
	* 都可以包含方法声明
	* 子类必须实现未实现的方法
	* 都遵循里氏替换原则
* 区别：
	* 抽象类可以有构造函数，接口不可以
	* 抽象类只能被单一继承，接口可以继承多个
	* 抽象类可以有成员变量，接口不能
	* 抽象类可以声明成员方法、虚方法、抽象方法、静态方法，接口中只能声明没有实现的抽象方法
	* 抽象类方法可以使用访问修饰符，接口中建议不屑，默认public
* 如何选择抽象和接口
	* 表示对象的用抽象类，表示行为拓展的用接口
	* 不同对象拥有的共同行为，往往可以使用接口实现
	例：动物是一类对象，会选择抽象类，而飞翔是一个行为，会选择接口

##### 面向对象七大原则
1. **单一职责原则 SRP**
	* 一个对象应该只包含单一的职责，并且该职责被完整地封装到一个类中
	* 对一个类而言，应该仅有一个引起它变化的原因（即只有该类唯一的职责需要修改时类才会被修改）
	一个类承担的职责越多，它被复用的可能性就越小，且一个类承担的职责过多，就会将职责耦合，其中一个职责变化时，可能会影响其他职责运作
2. **开闭原则 OCP**
	* 一个软件实体应该对扩展开放，对修改关闭。设计一个模块时应该使这个模块可以在不被修改的前提下扩展，即不修改源代码的情况下改变这个模块的行为
	* 软件实体可以指软件模块、一个由多个类组成的局部结构或一个独立的类
	具体：成员变量可以使用抽象类，通过派生新的不同功能子类实现扩展行为
3. **里氏替换原则 LSP**
	* 所有使用基类的地方都能够透明地使用其子类对象（透明：替换后功能不会发生变换，即子类对象可以透明地实现父类对象所有功能，能装到父类对象的容器中实现其功能）
	* 由于使用基类对象的地方都可以使用子类对象，因此程序尽量使用基类类型来对对象进行声明，运行时再用子类对象替换
4. **依赖倒置原则 DIP**
	* 高层模块不应该依赖底层模块而应该依赖抽象。抽象不依赖于细节，细节要依赖于抽象
	* 要针对接口编程而不应该针对实现编程
	理解：代码要依赖于抽象的类而不是具体的类。要针对接口或抽象类编程，而不是针对具体类编程。依赖倒转要求客户端依赖于抽象耦合，以抽象方式耦合是依赖倒转的关键
5. **接口隔离原则 ISP**
	* 客户端不应该依赖于它不需要的接口，一旦一个接口过大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需要知道与之相关的方法
	理解：一个类对另一个类的以来应该建立在最小的接口上，使用多个专门的接口，而不使用单一的接口，每一个接口应该承担一种相对独立的角色。使用接口隔离原则拆分接口时，首先满足单一职责原则，将一组相关的操作定义在一个接口中，满足高内聚条件下接口内方法越少越好
	**关键在于减少一个类对另一个类的依赖**
6. **迪米特法则 LOD **（也称最少知识原则）
	* 不和陌生人说话，只和朋友通信，每一个软件单位对其他的单位都只有最少的知识，且局限于那些与本软件单位密切相关的单位
	理解：一个软件实体应尽可能少和其他实体交互，这样在**一个模块修改时就会尽量少影响到其他模块**，扩展会相对容易，这是对软件实体间通信的限制。在狭义的迪米特法则中，如果两个类之间不彼此直接通信，那么这两个类就不应当发生直接的相互作用，可以通过第三方转发调用![[Pasted image 20221215184808.png]]
	* 对于一个对象，其朋友包括以下几类
		* 当前对象本身
		* 以参数传入自身方法的对象
		* 当前对象的成员对象
		* 当前对象所创建的对象
	* 用途：**控制信息的过载**
		* 在类的划分上应该尽量创建松耦合的类，类之间耦合度月底越有利与复用，一个处在松耦合的类被修改不会对其他关联的类造成太大波及
		* 类的结构设计上，每一个类都应该尽量降低其成员变量和函数的访问权限，一个对象对其他对象的引用应当降到最低
7. **合成复用原则 CRP**
	[合成复用原则](https://www.cnblogs.com/yangda/p/11954137.html#:~:text=%E4%B8%8B%E9%9D%A2%E6%88%91%E4%BB%AC%E4%B8%BE%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E6%9D%A5%E5%AF%B9%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%E7%90%86%E8%A7%A3%EF%BC%9A%201%20public%20class%20A%202%20%7B%203,B%20%3A%20A%2014%20%7B%2015%2016%20%7D)
	* 尽量使用对象组合，而不是继承来达到复用的目的
	* 即指在一个新的对象里通过关联关系（组合和聚合）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法来复用其已有功能
**总结**![[Pasted image 20221215185759.png]]![[Pasted image 20221215185931.png]]


### C#进阶
#### 简单数据结构类
##### ArrayList
* 本质上是一个**object类型**的数组，实现了很多方法
1. 声明:引用命名空间System.Collections
2. 增删查改
	1. 增加
		1. Add方法，可存储任意类型，在末尾增加
		2. AddRange，增加另一个ArrayList的内容到自身
		3. Insert，插入到指定位置
	2. Remove方法, 移除其中一个元素，从头找，找到删
	3. RemoveAt， 移除指定位置元素
	4. Clear， 清空
	5. 查找
		1. 得到指定位置元素 迭代器
		2. 查看元素是否存在 Contains方法
		3. 正向查找 IndexOf
		4. 反向查找 LastIndexOf 返回从头计数的索引
	6. 修改
		1. 使用索引器修改指定位置
	7. 长度
		1. 长度 Count
		2. 容量 Capacity
	8. **装箱拆箱**
		ArrayList本质上是一个可以自动扩容的object数组，由于用万物之父object存储数据自然存在装箱拆箱，需要移动内存

##### Stack
* 本质上也是object[]数组，只是封装了特殊的存取规则
* 增取查改
	* 增 Push 压栈
	* 取 Pop 出栈
	* 查 
		* 只能查看栈顶内容 Peek
		* 查找元素是否在栈中 Contain
	* 改
		* Clear 清空
	* 遍历
		* Count 长度
		* 使用foreach遍历（无法使用for循环），从栈顶到栈底
		* 将栈转为object数组再遍历 ToArray
	* 装箱拆箱：存在装箱拆箱

##### Queue
* 本质上也是object[]数组

##### HashTable


### 常见问题
#### 零碎知识点
* 函数等不能直接定义在命名空间里，需要定义在类中


### 实践
#### 贪吃蛇
##### 需求分析
**多场景切换**
1. 主界面：显示文字，提示游戏名，选择进入游戏和退出游戏，通过键盘选择高亮对应选项
2. 游戏界面：具有边框，蛇，和食物
	1. 每一帧根据位置重新绘制蛇
	2. 蛇触碰到食物增长身体
	3. 玩家操纵蛇改变移动方向
	4. 蛇头碰到蛇身或者边框游戏结束，返回开始界面
3. 结束界面：显示文字，提示游戏结束，选择重新开始和退出游戏，通过键盘选择高亮对应选项

#### 类设计
* Game类：
	* 属性：
		* 窗口宽高
		* 当前所在场景
	* 方法：
		* 初始化控制台窗口
		* 游戏主循环
		* 场景切换：开始，结束，游戏场景
	




