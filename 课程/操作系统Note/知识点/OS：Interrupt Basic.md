An **interrupt** is a signal generated by hardware or software to indicate that an event needs immediate attention from the CPU. When an interrupt occurs, the CPU stops its current operations and transfers control to a special function called an **interrupt handler** or **interrupt service routine (ISR)**, which handles the event that triggered the interrupt. Once the ISR is executed, the CPU resumes its prior tasks.
**Category**: **Interrupt**(from hardware), **Trap** (from software)
Trap can be divided into **SystemCall and Error**
### 1. **Interrupt Basics**
   - **Interrupts** are critical to efficient system operation, allowing the CPU to respond to urgent events (like I/O operations, hardware failures, etc.) without constantly polling devices to check their status.
   - Interrupts can be generated by:
     - **Hardware**: Triggered by external devices like keyboards, network cards, or disk controllers.
     - **Software**: Triggered by programs when certain conditions arise, like illegal instructions or system calls.

### 2. **Types of Interrupts**
   
#### 2.1 **Hardware Interrupts**:
   - **Generated by external hardware devices** (e.g., keyboards, disk controllers) when they need the CPU's attention.
   - Examples include:
     - **Keyboard interrupt**: When a key is pressed, the keyboard sends an interrupt to the CPU.
     - **Disk I/O interrupt**: After completing a read/write operation, the disk controller generates an interrupt to signal that data is ready.
   - Hardware interrupts can be:
     - **Maskable**: These interrupts can be disabled or ignored by the CPU, allowing the system to defer handling them if necessary.
     - **Non-maskable**: These are critical interrupts (e.g., hardware failures) that the CPU cannot ignore and must handle immediately.

#### 2.2 **Software Interrupts**:
   - **Triggered by software**, typically by issuing specific instructions like `int` in assembly language or invoking system calls in high-level programming.
   - Examples include:
     - **System calls**: A program requests kernel services (e.g., file operations) via software interrupts.
     - **Exception handling**: The CPU detects an error condition, such as division by zero or illegal memory access, and triggers an interrupt.

### 3. **Interrupt Handling Process**

#### 3.1 **Interrupt Request (IRQ)**
   - An **interrupt request (IRQ)** is sent by a device or software to signal that an interrupt event has occurred.
   - The CPU receives this signal and prepares to temporarily halt the current execution of a program to service the interrupt.

#### 3.2 **Interrupt Vector Table (IVT)**
   - When an interrupt occurs, the CPU must know which function (ISR) to execute to handle the event. It uses the **Interrupt Vector Table (IVT)**, a table in memory that contains addresses (pointers) to all the interrupt service routines (ISRs).
   - Each type of interrupt has a unique identifier (interrupt vector number), and this is used to locate the correct ISR in the IVT.

#### 3.3 **Interrupt Handling Steps**
   
1. **Interrupt Signal**: A hardware device or software sends an interrupt signal to the CPU.
2. **Save Context**: The CPU stops executing the current instruction stream and saves the current context (register values, program counter, etc.) onto the stack. This ensures that the interrupted task can resume once the interrupt has been serviced.
3. **Identify the Interrupt Source**: The CPU looks up the interrupt vector number in the IVT to determine which ISR to execute.
4. **Execute ISR**: The CPU jumps to the address of the ISR, executes the interrupt handling code, and resolves the interrupt event.
5. **Restore Context**: Once the ISR completes, the CPU restores the saved context and resumes executing the program from where it was interrupted.

### 4. **Prioritization of Interrupts**

In many systems, multiple interrupts can occur simultaneously. To manage this, the system assigns **priority levels** to different interrupts:

- **Priority Handling**: The CPU might have a priority system where high-priority interrupts (e.g., a non-maskable interrupt) are handled before lower-priority ones. If a higher-priority interrupt arrives while a lower-priority interrupt is being processed, the lower-priority interrupt may be paused to handle the critical one first.
  
- **Interrupt Nesting**: In some systems, interrupts can be nested, meaning one interrupt can interrupt another if it has a higher priority.

### 5. **Interrupt Controller**
   - **Interrupt controllers** like the **Programmable Interrupt Controller (PIC)** or **Advanced Programmable Interrupt Controller (APIC)** are used in complex systems to manage multiple interrupts.
   - The interrupt controller prioritizes interrupt requests and delivers them to the CPU. In modern systems with multiple cores, the APIC routes interrupts to specific CPU cores.

### 6. **Interrupt Latency**
   - **Interrupt latency** refers to the time between when an interrupt is generated and when the CPU starts executing the corresponding ISR.
   - Factors influencing interrupt latency:
     - Current CPU load.
     - The time it takes to save the current context.
     - How quickly the CPU can locate and begin executing the ISR.
   - Minimizing interrupt latency is important for real-time systems where timely processing of events is crucial.

### 7. **Interrupt Service Routine (ISR)**
   - The **ISR** is a special function designed to handle the event that caused the interrupt.
   - Key characteristics:
     - ISRs should be short and efficient, performing only the essential work to handle the interrupt. Prolonged execution of ISRs can delay handling of other interrupts or normal system operation.
     - After the ISR completes, it typically signals the original requesting device (or software) that the interrupt has been serviced (e.g., acknowledging the device).

### 8. **Interrupts in Modern Systems**

#### 8.1 **Edge-triggered vs. Level-triggered Interrupts**
   - **Edge-triggered interrupts**: Triggered on the rising or falling edge of a signal (e.g., when a signal goes from 0 to 1).
   - **Level-triggered interrupts**: Triggered when the signal remains at a certain level (e.g., signal stays high).

#### 8.2 **Software Interrupts and System Calls**
   - In modern operating systems, **system calls** are a common form of software interrupt. When a user-space program needs to request kernel-level operations (e.g., opening a file, allocating memory), it triggers a software interrupt, transferring control to the kernel to perform the requested operation.

#### 8.3 **Polling vs. Interrupts**
   - **Polling** is an alternative to interrupts, where the CPU constantly checks (or "polls") a device to see if it needs attention.
   - **Interrupts** are more efficient than polling, as they only occur when necessary, reducing CPU usage and improving system responsiveness.

### 9. **Interrupt Example (Hardware)**
   - **Keyboard Interrupt**:
     1. When a key is pressed, the keyboard sends an interrupt signal to the CPU via the PIC or APIC.
     2. The CPU halts the current task, saves its context, and looks up the appropriate ISR in the IVT (e.g., the keyboard ISR).
     3. The keyboard ISR is executed, reading the key press data from the keyboard buffer and storing it in memory.
     4. Once the ISR finishes, the CPU restores the context and resumes the previously interrupted task.

### 10. **Interrupt Example (Software)**
   - **System Call Interrupt**:
     1. A program wants to write data to a file. It calls the appropriate system call (e.g., `write()` in Linux).
     2. The system call triggers a software interrupt (usually through an assembly instruction like `int` on x 86 architectures).
     3. The CPU transfers control to the kernel's ISR for system calls, which handles the file operation.
     4. Once the operation is complete, control is returned to the user-space program.

### Summary of Interrupt Mechanism:
1. **Interrupt Request**: A signal from hardware or software interrupts the CPU's normal operation.
2. **Context Saving**: The CPU saves the current state to ensure that the interrupted task can resume afterward.
3. **Interrupt Vector Lookup**: The CPU identifies which ISR to execute based on the type of interrupt.
4. **ISR Execution**: The interrupt is handled by executing the ISR.
5. **Context Restore**: The CPU restores the saved state and resumes the interrupted task.

Interrupts are essential for efficient and responsive system design, enabling the CPU to handle multiple asynchronous events (like I/O, hardware failures, and system calls) while minimizing wasted CPU cycles.