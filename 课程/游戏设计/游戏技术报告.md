3190102196 展翼飞
***
### 行为树
#### 1. 什么是行为树
有限状态机和行为树是目前最常见的两种用来实现游戏角色AI的工具。
行为树(behavior tree)是用来实现非人工角色复杂行为的工具，它具有下面这些特征：
1. **行为树是树：** 执行时从根结点开始按照指定的顺序遍历，直到到达终结状态。
2. **叶子结点都是可执行的行为：** 叶子结点会进行具体的操作，可以是一个简单的检测操作，也可以是一个更复杂的操作，结点会返回状态信息(成功，失败，运行中)。
3. **内部结点控制树的遍历：** 内部结点会根据孩子结点返回的状态信息，按照特定的规则确定下一个执行的结点。
游戏行业使用行为树(behavior tree)来定义非玩家角色的行为：虚幻引擎和Unity引擎都提供了专门的工具来帮助用户定义行为树。

#### 2. 行为树解析
下图给出了行为树的不同结点类型及其对应的图示：
![[Pasted image 20240508123734.png]]

行为树结点的一次触发称为一次tick，会返回**成功(success)**，**失败(failure)**，**运行中(running)** 的状态信息给它的父结点。
**执行结点(execution node)：** 行为树的叶子结点，可以是动作结点(action node)或条件结点(condition node)。对于条件结点(condition node)会在一次tick后立马返回成功或失败的状态信息。对于动作结点(action node)则可以跨越多个tick执行，直到到达它的终结状态。一般来说，条件结点用于简单的判断(比如钳子是否打开?)，动作结点用于表示复杂的行为(比如打开房门)。
**控制结点(control node)：** 控制结点是行为树的内部结点，它们定义了遍历其孩子结点的方式。控制结点的孩子可以是执行结点，也可以是控制结点。**顺序(Sequence)**，**备选(Fallback)**，**并行(Parallel)** 这3种类型的控制结点可以有任意数量的孩子结点，它们的区别在于对其孩子结点的处理方式。而**装饰(Decorator)结点**只能有一个孩子结点，用来对孩子结点的行为进行自定义修改。

![[Pasted image 20240508124050.png]]
顺序结点：按顺序执行孩子结点直到其中一个孩子结点返回失败状态或所有孩子结点返回成功状态。
![[Pasted image 20240508124115.png]]
备选结点：按顺序执行孩子结点直到其中一个孩子结点返回成功状态或所有孩子结点返回失败状态。一般用来实现角色的备选行为。
![[Pasted image 20240508124134.png]]

并行结点：“并行执行”所有孩子结点。直到至少M个孩子(M的值在1到N之间)结点返回成功状态或所有孩子结点返回失败状态。

#### 3. 行为树示例
如果只存在一个地点A，那么行为树很简单，到A处，找到物体。如下图所示：
![[Pasted image 20240508123934.png]]
上图中我们使用了一个动作结点表示到A处这一动作。在机器人还没有移动到A处前，这一动作结点会返回运行中(running)状态。我们还使用了一个条件结点，用来判断机器人是否找到了物体(具体实现可以通过相机拍摄照片，然后进行图像识别)。
行为树的一个很常用的设计规则就是使用显式成功条件(explicit success condition)。简单来说，就是在执行动作前总是先进行条件检测。比如，先检测机器人是否已经在A处，如果在就不执行去A处的动作，直接返回成功状态。如下图所示：
![[Pasted image 20240508124008.png]]
我们的机器人工作的环境可能包含了多个地点，我们期望它可以尝试到所有已知的地点搜寻物体，在搜寻到物体后结束搜索。这可以通过添加一个备选结点作为根节点来实现，如下图所示：
![[Pasted image 20240508124220.png]]
如果我们期望机器人可以同时搜寻多个不同的物体(比如苹果和橘子)，可以通过添加并行结点实现。

- 如果我们期望找到一个苹果或一个橘子后就停止搜索(或条件)，我们在并行结点的一个子结点返回成功状态后就返回成功状态。
- 如果我们期望找到一个苹果和一个橘子后就停止搜索(与条件)，我们在并行结点的所有子结点返回成功状态后返回成功状态。
- 如果我们期望在搜索橘子前先搜索苹果，可以使用顺序结点代替并行结点。

#### 4.  装饰器（decorator）和黑板（blackboard）
我们可以使用装饰器结点(decorator node)来对行为树进行优化。考虑上面的在多个地点搜寻物体的行为树，如果地点数目达到20个以上，整个行为树看上去就会变得非常庞大，也为我们进一步添加新的结点带来麻烦。
下面是避免这些麻烦的常用方法：
- **引入装饰器结点(decorator node)：** 相较于每增加一个搜寻地点就复制一份完全相同的子树，我们可以定义一个规则为Repeat的装饰器结点，用来重复执行它的孩子结点，完成搜寻多个地点。
- **在每一次迭代更新目标位置：** 使用一个队列存储所有待搜寻地点，每次迭代从队列中取出一个地点进行搜寻，当队列为空时，所有地点都被搜寻完毕。
为了存储可以被多个结点访问的共享信息(比如上面提到的存储有所有待搜寻地点的队列)，我们引入黑板(blackboard)的概念。黑板是一块可以被结点读写的公共存储区。
针对我们的例子，我们为行为树添加一个Repeat装饰器结点和一个GetLoc的动作结点，用来在每一次迭代读取新的搜寻地址，如下图所示：
![[Pasted image 20240508124440.png]]
我们也可以利用黑板(blackboard)实现其它一些任务。比如：在找到苹果或橘子后在黑板上记录下它们的位置信息，然后在添加的Speak动作结点中读取它们，让机器人说出在哪里找到了苹果或橘子。还有对于找到的物体不同，后续结点可以根据黑板记录的信息采取不同的处理规则。

#### 5. 行为树和有限状态机比较
- 理论上，行为树和状态机具有相同的表达能力，可以实现相同的功能。
- 行为树更好还是状态机更好主要看所要定义的行为是更偏向模块化，还是更偏向反应式。一般来说，行为树更方便进行组合和修改，状态机更方便进行反应式动作设计。
有限状态机更方便管理高优先级的操作行为(比如机器人处于正常状态还是充电状态)，行为树更适合定义复杂的行为，比如处理错误恢复等等。实践中，混合使用两者可能会是更好的选择。下图给出了混合使用行为树和状态机定义我们例子中的机器人行为的图示：![[Pasted image 20240508124611.png]]