* 没有频率要求，可以尝试降低时钟周期保证下板子不出现时序问题

* 补实验过程出现注意点
	* L0
		* 注意生成bit流之后，bit流文件的路径
		* 注意引脚约束（工具约束不能直接用默认，注意点平标准和是否全部约束）
		* 工具约束在综合之后（约束完需要重新综合），直接写文件约束不需要再次综合
		* 下板子前先多跑跑测试debug
		* 当前Vivado暂不支持.edf文件的仿真，仿真过程中不会报错，但是无有效波形输出
	* 模块生成：
		* ROM可以在需要的工程里直接生成，并关联初始化.coe文件

* Stall和Flush，阶段寄存器Stall时寄存器保留上一时钟周期的值，而Flush则为寄存器有效值全部置零
### Lab1
* **实现模块：** Hazard detection， rv32i core（主要为多路选择器）， cpu controller
![[Pasted image 20231021100622.png|500]]
#### Hazard梳理
![[Pasted image 20231021095048.png|500]]
##### 1.结构冒险
* 原因：在WB阶段写寄存器时同时有ID阶段的指令读寄存器
* 解决方式：寄存器在时钟上边沿写，下边沿读

##### 2.数据冒险
* 原因：当前指令需要写回寄存器的结果在WB阶段前前就要被之后的指令读相应寄存器
![[Pasted image 20231021095836.png|500]]
* 解决方法；
	* R | I | J 或LUI, AUIPC 后读相应寄存器，则从EXE或MEM阶段的ALU结果forward到ID（对应forward control unit控制ID多路选择器的线1 2）
	* L类型指令后紧接S类型指令读相应寄存器，则从MEM阶段的取回值forward到EXE（对应EXE阶段下方准备传给MEM WriteData的多路选择器线1）
	* L类型指令一周期后接读相应寄存器指令，则从MEM阶段的取回值forward到ID（对应forward control unit控制ID多路选择器的线3）
	* L类型指令紧接R | I | J或LUI，AUIPC后读相应寄存器，无法forward（当前指令load时下一条已经在exe），需要Flush ID-EXE并Stall之前的寄存器（L指令在EXE阶段时判断）![[Pasted image 20231021101741.png]]
##### 3.控制冒险
* 策略：Predict branch taken
* ID阶段在检测到跳转指令后由Hazard Control Unit输出控制信号，Flush掉IF-ID寄存器的一个cycle使一个周期后IF取到的地址为ID阶段当前时钟末上边沿产出的需要跳转正确地址
![[Pasted image 20231022092056.png]]

