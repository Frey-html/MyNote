学号：3190102196  姓名：展翼飞

#### 问题重述
关键为通过蒙特卡洛算法设置黑白棋AI，使AI能够：
1. 构建蒙特卡洛搜索树
2. 读取对手行动并转换为对应坐标，更新蒙特卡洛搜索树节点
3. 根据更新后的蒙特卡洛搜索树进行搜索得到一步行动节点并返回

#### 设计思想
使用蒙特卡洛搜索树，框架如下：
**蒙特卡洛节点类**：包含该节点下棋的颜色，所有可能的子节点行动列表，ucb值等
**蒙特卡洛搜索树类**：包含当前蒙特卡洛搜索树根节点以及随机搜索，反向传播等方法
**AIPlayerer类**：完成蒙特卡洛搜索树初始化并调用

#### 代码内容
##### 节点类
###### 属性：
![[Pasted image 20240416165209.png]]
expendedChildPosList：该节点已经扩展的子节点位置
childPosList：该节点所有子节点位置
childList：该节点所有子节点对象
flipped_pos：父节点到该节点棋盘翻转位置

###### 方法：
init：初始化节点
![[Pasted image 20240416165308.png]]
![[Pasted image 20240416165328.png]]
expand：随机扩展一个子节点，并把它添加到已扩展子节点列表
![[Pasted image 20240416165409.png]]
![[Pasted image 20240416165435.png]]
![[Pasted image 20240416165727.png]]

##### 搜索树类
###### 属性
![[Pasted image 20240416165855.png]]
root：当前搜索树根节点
timeLimit：单次得到搜索结果的时间限制
###### 方法
Search：完成一次搜索并得到当前下棋最佳位置，循环经历遍历，扩展，模拟，反向传播的步骤
![[Pasted image 20240416170140.png]]
traverse：从当前节点出发向下遍历寻找第一个未完全展开的节点或者结局节点，返回该节点的扩展或者结局节点
![[Pasted image 20240416170310.png]]
randomRollout：从当前节点开始随机模拟游戏进程，得到结果；需要复制一个临时棋盘避免对棋盘的更改
![[Pasted image 20240416170434.png]]
backPropagate：从当前节点反向传播更新路径节点的ucb
![[Pasted image 20240416170530.png]]
getAdversaryMove：轮到AIPlayer下棋时先调用，根据棋盘的修改获取对手的行动，创建相应节点并更新自己的蒙特卡洛搜索树
![[Pasted image 20240416170609.png]]

##### AiPlayer类
get_move:完成蒙特卡洛搜索树类的初始化，并建立一个棋盘以供搜索与更新搜索树使用；在获取行动时调用搜索树根据对手行动更新，并完成一次搜索循环得到结果
![[Pasted image 20240416170750.png]]

#### 实验结果
在实验测试环节无法正常读取到game对象，继而无法得知对手行动，游戏无法正常进行，不能通过测试
![[Pasted image 20240416164517.png]]


