参考资料：[计算机组成原理：简单页表和多级页表（虚拟内存的映射）](https://blog.csdn.net/zhizhengguan/article/details/121276581)
[[Memory：virtual memory and TLB]]
### 页表（Page Table）概述

**页表（Page Table）** 是操作系统用于实现虚拟内存（Virtual Memory）管理的关键数据结构。它将程序的虚拟地址（Virtual Address）映射到物理内存中的实际地址（Physical Address）。通过页表，系统能够有效地管理内存分配和地址转换，使得每个进程可以认为自己拥有连续的虚拟内存空间，而实际物理内存可以分散存储，甚至部分数据可以在硬盘或其他外存中。

虚拟内存通过**分页（Paging）** 技术来管理，虚拟地址空间和物理地址空间都被划分成固定大小的块，称为**页（Page）** 和**页框（Page Frame）**，页表则记录了虚拟页与物理页框之间的映射关系。

### 页表的基本工作原理

1. **虚拟地址**：当 CPU 执行程序时，访问的都是虚拟地址。虚拟地址被分为两部分：
   - **页号（Page Number）**：标识该虚拟地址所属的页。
   - **页内偏移量（Page Offset）**：标识该地址在页内的具体偏移位置。
2. **页表查找**：操作系统会为每个进程维护一个页表，页表中的每一项记录了虚拟页与物理页框的映射。当访问虚拟地址时，CPU 使用虚拟地址中的页号查找对应的物理页框号，并将其与页内偏移量组合，形成物理地址。
3. **页表项（Page Table Entry, PTE）**：页表中的每一项称为页表项，记录了页号和页框号的映射，同时还包括一些控制信息（如是否有效、是否在内存、读写权限等）。

### 页表的结构

由于虚拟内存地址空间通常比物理内存空间大得多，为了高效管理，现代计算机系统通常不直接使用单层页表，而采用多级页表或其他优化技术来减少内存开销。常见的页表结构有以下几种：

#### 1. **单级页表（Single-level Page Table）**
在早期系统或小型嵌入式系统中，使用简单的单级页表。单级页表为每个虚拟页号提供一个直接映射到物理页框的条目。页表项通常存储以下信息：
- **物理页框号**：该虚拟页对应的物理页框的编号。
- **有效位（Valid Bit）**：指示该页是否有效。如果该位为无效，表示该页可能未被加载到内存。
- **访问权限位**：表示该页的读写权限，防止非法访问。
- **脏位（Dirty Bit）**：标记该页是否被修改，未修改的页可以直接丢弃，不必写回硬盘。
![[Pasted image 20240923121840.png]]
##### 优缺点：
- **优点**：实现简单，地址转换速度快（只需一次页表查找）。
- **缺点**：对于 64 位系统或大内存应用程序，单级页表可能过于庞大，存储页表本身的内存开销较高。

#### 2. **多级页表（Multi-level Page Table）**
为了解决单级页表过大的问题，现代操作系统通常采用**多级页表**，例如**二级页表（Two-level Page Table）**、**三级页表** 或 **四级页表**。多级页表通过将虚拟地址空间划分为多个层次，减少页表的存储开销。

##### 多级页表的工作原理：
- **虚拟地址划分**：虚拟地址分为多个部分，分别用于不同级别页表的索引。例如，在二级页表中，虚拟地址可以分为：
  1. **一级页表索引**：用来查找一级页表的条目。
  2. **二级页表索引**：用来查找二级页表的条目。
  3. **页内偏移量**：用于确定数据在物理页框内的位置。
- **逐级查找**：当访问虚拟地址时，首先在一级页表中查找得到二级页表的位置，然后在二级页表中查找物理页框的编号。最后结合页内偏移量形成物理地址。

##### 多级页表结构示意图：
```
虚拟地址结构:
| 一级页表索引 | 二级页表索引 | 页内偏移量 |

多级页表查找流程:
虚拟地址 -> 一级页表 -> 二级页表 -> 物理页框号 -> 物理地址
```
![[Pasted image 20240923121902.png]]![[Pasted image 20240923170149.png]]
##### 优缺点：
- **优点**：减少了页表所需的内存空间，因为仅需为实际使用的虚拟地址分配页表。未使用的地址空间无需页表条目，节省内存。
- **缺点**：地址转换速度较慢，因为多级页表需要进行多次内存访问来完成虚拟地址到物理地址的映射。

#### 3. **倒排页表（Inverted Page Table）**
倒排页表是为了解决大规模虚拟地址空间的问题，尤其是在 64 位系统中。与普通页表不同，倒排页表基于物理内存页框而不是虚拟地址进行管理。

##### 工作原理：
- 倒排页表中的每一项对应一个物理页框，而不是一个虚拟页。每个条目记录了哪个虚拟地址映射到该物理页框。
- 在查找时，系统必须遍历倒排页表，找到对应虚拟地址的条目。

##### 优缺点：
- **优点**：节省内存，因为倒排页表的大小与物理内存大小成正比，而不是虚拟地址空间。
- **缺点**：查找效率低，需要使用哈希或遍历方式查找虚拟地址对应的物理页框。

### 页表项（Page Table Entry, PTE）

**页表项** 是页表中的每一条记录，包含了与该虚拟页对应的物理页框的地址信息以及一些额外的控制位。典型的页表项结构包括：

1. **物理页框号（Physical Page Frame Number, PFN）**：
   - 虚拟页映射到的物理内存页框的编号，用于形成物理地址。
   
2. **有效位（Valid Bit）**：
   - 指示该页是否在物理内存中。如果无效，可能需要触发页错误（Page Fault）将页从磁盘加载到内存。

3. **访问位（Accessed Bit）**：
   - 指示该页是否被访问过（读或写）。用于操作系统优化页面调度。

4. **脏位（Dirty Bit）**：
   - 指示该页是否被修改过。如果设置为脏，则在替换该页之前，需要将其写回磁盘。

5. **权限位（Permission Bits）**：
   - 决定该页是否可读、可写或可执行，防止程序非法操作。

6. **页表属性**：
   - 一些高级操作系统和处理器可能包含额外的控制位，如缓存策略、页面大小、特权级等。

### 地址转换流程示意

1. **虚拟地址分解**：
   - 假设虚拟地址为 `0xABCDEF01`，其中 `0xABC` 是页表索引，`0xDEF` 是二级页表索引，`0x01` 是页内偏移量。
   
2. **一级页表查找**：
   - 使用 `0xABC` 作为一级页表索引，找到一级页表中的条目。

3. **二级页表查找**：
   - 根据一级页表的结果，找到二级页表，使用 `0xDEF` 作为索引查找二级页表的条目。

4. **形成物理地址**：
   - 最终通过页表查找得到物理页框号，将其与页内偏移量 `0x01` 结合，形成完整的物理地址。

### TLB（Translation Lookaside Buffer）

由于页表查找涉及多次内存访问，会增加内存访问延迟。为了解决这个问题，现代处理器中引入了**TLB（Translation Lookaside Buffer）**，它是一个小型、快速的缓存，用于存储最近的页表映射结果。当 CPU 访问某个虚拟地址时，首先查找 TLB，如果命中，便可立即得到对应的物理地址。如果未命中，再去查页表。

- **TLB 命中率高**，因为程序的访问往往具有局部性，大部分地址转换请求可以通过 TLB 缓存满足。
- **TLB 缺失**：当 TLB缺失时，CPU 会根据页表查找得到映射，并将结果存入 TLB，以便后续访问加速。

### 疑问：
#### 页表是专门的硬件结构么？
**页表（Page Table）** 并不是一个专门的硬件结构，而是一个**存储在内存中的数据结构**，其目的是管理虚拟地址到物理地址的映射。页表本身是由操作系统负责维护和管理的，硬件（通常是 CPU 的内存管理单元 MMU）负责读取和使用这些页表进行地址转换。

下面详细说明页表的特性以及它在存储系统中的位置和作用。

##### 1. **页表的性质**
   - **数据结构而非硬件结构**：页表是由操作系统创建和维护的一个数据结构。每个进程在创建时，操作系统会为其分配和初始化一个页表，页表存储在**主存（RAM）** 中。硬件如 MMU 依赖于这些页表来进行虚拟地址到物理地址的转换。
   
   - **存储虚拟地址到物理地址的映射**：页表的每个条目（PTE, Page Table Entry）包含一个虚拟页号（VPN）和其对应的物理页号（PPN）映射。它还可能包含额外的信息，比如页的权限（读/写/执行权限）、缓存属性和是否已经驻留在物理内存中（用于页面交换机制）。

##### 2. **页表的位置：主存**
   - **页表存储在内存中**：页表并不在缓存（Cache）或寄存器等高速硬件中，而是存储在主存（RAM）中。这意味着当需要从页表中查找虚拟地址映射时，如果没有缓存机制，系统需要访问内存，从而影响访问速度。
   
   - **内存中的多级结构**：由于页表存储在内存中，直接访问一个庞大的单级页表可能导致大量的内存占用。因此，现代系统通常使用**多级页表**，将虚拟地址的翻译分解为几级，以减少每次访问时查找页表的内存开销。

##### 3. **硬件支持：MMU 与 TLB**
   虽然页表本身是一个数据结构，存储在内存中，但 CPU 中有专门的硬件单元（**内存管理单元 MMU**）负责从页表中读取和翻译虚拟地址。这些硬件加速了虚拟地址到物理地址的转换过程：
   * 页表基址寄存器（PTBR）或CR3寄存器
	- **页表基址寄存器（PTBR）**：这个寄存器存储了当前进程的页表的起始地址（物理地址，否则会递归），指向存储在内存中的页表的起始位置。
	    - 每次进行地址转换时，内存管理单元（MMU）会根据虚拟地址，通过页表基址寄存器中的地址找到页表，然后从内存中的页表中查找虚拟地址对应的物理地址。
	    - 当进程切换时，操作系统会将下一个进程的页表基址加载到这个寄存器中，从而使MMU使用新进程的页表进行地址转换。
	- **x86架构的CR3寄存器**：在x86和x86_64架构中，页表基址寄存器被称为**CR3寄存器**，它保存了页表的物理地址。在64位系统中，CR3寄存器指向的是页全局目录（Page Global Directory, PGD），即多级页表的最顶层目录。

   - **MMU（Memory Management Unit）**：MMU 是 CPU 中的一个硬件模块，负责通过查阅页表来将虚拟地址翻译成物理地址。MMU 在处理器中起到重要的桥梁作用，它配合操作系统管理页表，直接与主存交互来检索页表中的映射信息。

   - **TLB（Translation Lookaside Buffer）**：TLB 是一个专门的硬件缓存，用于存储最近使用的页表条目。它加速了虚拟地址到物理地址的转换，避免频繁访问内存中的页表。
     - 当虚拟地址的转换在 TLB 中命中时，MMU 可以直接使用缓存中的映射，避免访问内存中的页表，从而显著提升速度。
     - 如果 TLB 未命中，则 MMU 需要访问主存中的页表，查找虚拟地址的对应物理地址。

##### 4. **多级页表的作用**
   - **节省内存**：多级页表是为了应对大量内存使用的一种优化手段，尤其是在现代系统中虚拟地址空间可能非常大（如 64 位系统）。将页表拆分为多级，可以显著减少实际内存中存储的页表的大小。
     - **一级页表**：直接映射虚拟地址到物理地址，但由于虚拟地址空间较大，单级页表会占用大量的内存空间。
     - **多级页表**：将虚拟地址分为多个部分，使用每个部分依次查找页表层级，最终找到目标的物理页号。这样做的好处是只有需要的部分页表需要常驻内存，大大节省了内存空间。

##### 5. **页表与进程的关系**
   - **每个进程都有独立的页表**：操作系统为每个进程维护一个独立的页表，这个页表存储了该进程的虚拟地址空间到物理内存的映射。
     - 由于不同进程的虚拟地址空间是独立的，即使它们使用相同的虚拟地址，它们对应的物理地址也可以不同。这种机制保证了进程之间的内存隔离。

##### 6. **页表与页面交换（Paging）**
   - 当物理内存不足时，操作系统可能将一些不常用的内存页从物理内存中交换到硬盘上。这时候页表的条目会被更新，标记该页已被交换出，并指向硬盘上的存储位置。
   - 当该页再次被访问时，操作系统会触发一个**页面缺失（Page Fault）** 中断，从硬盘中将该页重新加载到物理内存，然后更新页表。

##### 7. **页表与地址转换的完整流程**
   以下是 CPU 使用页表进行地址转换的基本流程：
   1. **CPU 生成虚拟地址**：程序执行时，CPU 发出一个虚拟地址。
   2. **TLB 查找**：MMU 首先查找 TLB 中是否有该虚拟地址对应的物理地址映射。如果命中，则直接使用缓存的物理地址。
   3. **页表查找（如果 TLB 未命中）**：如果 TLB 未命中，MMU 会从内存中的页表中查找该虚拟地址的映射。对于多级页表，MMU 会逐级查找，直到找到对应的物理地址。
   4. **返回物理地址**：一旦找到映射，MMU 会返回物理地址，将其加载到 TLB 中，并将数据从内存或缓存中加载到 CPU。

#### 多级页表中最下级页表存储的虚拟地址是完整的还是只存储最后的索引？
**多级页表的每一级页表都只存储虚拟地址的一部分作为索引**。多级页表通过将虚拟地址划分为多个部分，每一级页表使用其中一部分索引来查找下一级页表的地址或最终映射到的物理页框号。这样设计的目的是节省内存，减少页表的空间开销。

##### 多级页表的工作机制：
虚拟地址在多级页表中被分成多个部分，每一级页表根据虚拟地址的一部分来查找下一级页表或物理页框号。以 32 位虚拟地址和 4 KB 页大小为例，可以用多级页表将虚拟地址分解为多个部分。
##### 1. 虚拟地址的分段：
假设使用两级页表，32 位虚拟地址可以分为三部分：
- **前 10 位**：用于在**第一级页表**中找到指向下一级页表的指针（页目录表）。
- **中间 10 位**：用于在**第二级页表**中找到物理页框号。
- **最后 12 位**：用于在物理页中确定页内偏移，表示该页内的具体地址。

如果使用三级页表或更多级别，虚拟地址就会被分成更多部分，每一级页表只负责查找一部分索引。

##### 2. 每一级页表的存储内容：
- **第一级页表**（页目录表）：存储的是虚拟地址的第一个索引部分，指向**下一级页表**（例如页表二）。
- **第二级页表**（页表二）：存储的是虚拟地址的第二部分索引，指向物理页框号（或指向下一级页表，如果是三级页表）。
- **最后一级页表**：存储的是虚拟地址的最后一部分索引，映射到实际的物理页框号。

##### 3. 示例：
假设虚拟地址是 32 位，页大小为 4 KB，则页内偏移需要 12 位，那么虚拟地址剩余的 20 位可以用于页表索引。如果我们使用两级页表结构，这 20 位会分成两部分：
- **前 10 位**：用于第一级页表的索引。
- **后 10 位**：用于第二级页表的索引。

每一级页表中都只存储虚拟地址的一部分索引，并将该部分索引映射到下一级页表地址或物理页框号。通过这种方式，多级页表节省了内存空间，同时也允许系统处理非常大的虚拟地址空间。

#### 页与块的关系
是的，**虚拟地址到物理地址的映射（通过页表或 TLB）是以页为单位**，而**物理地址访问内存时，缓存（cache）是以块为单位**。二者的单位不必相等，它们的作用和粒度不同。

##### 1. **虚拟地址到物理地址的映射（以页为单位）：**
- 虚拟地址通过页表转换为物理地址时，是以**页（page）**为单位进行管理的。
- 页的大小通常是**固定的**，例如 4 KB、2 MB 或 1 GB 等，具体大小取决于操作系统和硬件的配置。
- 页表存储的是**虚拟页号 (VPN)** 和对应的**物理页框号 (PFN)**，即虚拟地址的高位部分（页号）映射到物理地址的高位部分（页框），然后加上页内偏移来得到完整的物理地址。

##### 2. **物理地址到缓存的映射（以块为单位）：**
- 当处理器从内存中加载数据时，**缓存（cache）** 是以**块（cache line 或 cache block）**为单位进行管理的。缓存块的大小通常为 32 字节、64 字节或 128 字节等，具体大小取决于缓存的设计。
- 缓存的工作方式是基于物理地址，即缓存中存储的是从物理内存中加载的**物理地址块**，它的粒度比页要小。
- 当 CPU 访问某个物理地址时，如果该地址对应的数据块已经在缓存中（称为缓存命中），那么可以直接从缓存中读取该块数据。否则（缓存未命中），则需要从内存中加载数据并存入缓存。

##### 3. **页与块不必等大：**
- 页和缓存块的大小一般不同。**页通常较大**，如 4 KB，而**缓存块较小**，如 64 字节。因此，**一页内存可以包含多个缓存块**。
- 一个**虚拟页**通过地址转换机制（TLB 或页表）映射到**物理页框**，然后物理地址再以**缓存块**为单位被缓存系统管理。
- 当页表将虚拟地址映射为物理地址后，具体的内存访问是以块为单位进行的。也就是说，内存访问时不需要一次读取或存储整页，而是读取或写入一个或多个缓存块。

##### 举例：
- 假设**页大小为 4 KB**，而**缓存块大小为 64 字节**，那么一个页可以包含**64 个缓存块**。
- 当虚拟地址通过页表转换为物理地址时，映射的单位是整个**4 KB 的页**。
- 但是当从内存加载数据时，处理器通常只会加载其中的一个或多个**64 字节的缓存块**，并将其存入缓存。

##### 总结：
- **页表和 TLB** 负责虚拟地址到物理地址的转换，单位是**页**。
- **缓存**负责将物理地址映射到更快的存储器，单位是**块**。
- 二者的单位大小不必相等，通常一页包含多个缓存块。这种设计提高了内存管理的灵活性和缓存的效率。