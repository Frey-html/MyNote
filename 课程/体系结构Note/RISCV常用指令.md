
单周期 cpu 数据通路：
![[Pasted image 20240909112748.png]]
五级流水线 CPU（Lab 1 实现forwarding）原理图
![[Pasted image 20240909152719.png]]

### 指令类型介绍
![[Pasted image 20240910084732.png]]
在 **RISC-V** 指令集中，指令格式主要分为六种类型：**R 型**、**I 型**、**S 型**、**B（SB） 型**、**U 型** 和 **J（UJ） 型**。相同大类指令格式相同，每种类型的指令格式用于不同的操作，并且格式的字段定义不同。下面是对每种指令类型的介绍：
#### 操作码
不同类型指令可能还有不同指令子集，一般相同子集的 opcode 相同（同种功能类型和操作数的指令）：**L 型指令**（Load-type 指令，加载指令）通常用于从内存加载数据，并且它们属于 **I 型指令** 的子集
##### 1. **算术和逻辑运算（R 型指令）**

这些指令通常对寄存器进行操作，并将结果存储到寄存器中。

|指令|功能|Opcode|funct3|funct7|
|---|---|---|---|---|
|`ADD`|寄存器加法|0110011|000|0000000|
|`SUB`|寄存器减法|0110011|000|0100000|
|`AND`|按位与|0110011|111|0000000|
|`OR`|按位或|0110011|110|0000000|
|`XOR`|按位异或|0110011|100|0000000|
|`SLL`|左移逻辑|0110011|001|0000000|
|`SRL`|右移逻辑|0110011|101|0000000|
|`SRA`|右移算术|0110011|101|0100000|

##### 2. **立即数运算（I 型指令）**

这些指令使用立即数作为操作数之一。

|指令|功能|Opcode|funct3|
|---|---|---|---|
|`ADDI`|立即数加法|0010011|000|
|`ANDI`|立即数按位与|0010011|111|
|`ORI`|立即数按位或|0010011|110|
|`XORI`|立即数按位异或|0010011|100|
|`SLLI`|立即数左移逻辑|0010011|001|
|`SRLI`|立即数右移逻辑|0010011|101|
|`SRAI`|立即数右移算术|0010011|101|

常见 L 型（加载）指令：

| 指令    | 功能                 | Opcode  | funct3 |
| ----- | ------------------ | ------- | ------ |
| `LW`  | 加载字（从内存加载 32 位数据）  | 0000011 | 010    |
| `LH`  | 加载半字（从内存加载 16 位数据） | 0000011 | 001    |
| `LB`  | 加载字节（从内存加载 8 位数据）  | 0000011 | 000    |
| `LBU` | 无符号加载字节            | 0000011 | 100    |
| `LHU` | 无符号加载半字            | 0000011 | 101    |
##### 3. **内存访问（I 型和 S 型指令）**

用于加载和存储数据。

|指令|功能|Opcode|funct3|
|---|---|---|---|
|`LW`|从内存加载字|0000011|010|
|`LH`|从内存加载半字|0000011|001|
|`LB`|从内存加载字节|0000011|000|
|`SW`|向内存存储字|0100011|010|
|`SH`|向内存存储半字|0100011|001|
|`SB`|向内存存储字节|0100011|000|

##### 4. **分支和跳转（B 型和 J 型指令）**

用于控制程序流。

|指令|功能|Opcode|funct3|
|---|---|---|---|
|`BEQ`|等于时分支|1100011|000|
|`BNE`|不等时分支|1100011|001|
|`BLT`|小于时分支|1100011|100|
|`BGE`|大于等于时分支|1100011|101|
|`JAL`|无条件跳转并链接|1101111|-|
|`JALR`|无条件跳转并链接寄存器|1100111|000|

##### 5. **系统指令（I 型指令）**

涉及与处理器状态和异常相关的操作。

| 指令       | 功能         | Opcode  | funct3 |
| -------- | ---------- | ------- | ------ |
| `ECALL`  | 环境调用       | 1110011 | 000    |
| `EBREAK` | 环境断点       | 1110011 | 000    |
| `CSRRW`  | 读写控制状态寄存器  | 1110011 | 001    |
| `CSRRS`  | 设置控制状态寄存器位 | 1110011 | 010    |

#### 1. **R 型指令（R-Type Instruction）**
R 型指令用于寄存器到寄存器的操作，通常用于算术、逻辑和位操作。
##### 格式：

| 字段     | 位宽     | 说明              |
| ------ | ------ | --------------- |
| opcode | 7 bits | 操作码，标识指令类型      |
| rd     | 5 bits | 目标寄存器，存放结果      |
| funct3 | 3 bits | 功能码，标识具体操作      |
| rs1    | 5 bits | 第一个源寄存器         |
| rs2    | 5 bits | 第二个源寄存器         |
| funct7 | 7 bits | 扩展功能码，标识具体的操作类型 |

##### 示例指令：

- **ADD rd, rs1, rs2**：将 `rs1` 和 `rs2` 的值相加，结果存入 `rd`。

#### 2. **I 型指令（I-Type Instruction）**

I 型指令用于立即数运算、内存加载、以及某些控制指令（如 `jalr`）。

##### 格式：

|字段|位宽|说明|
|---|---|---|
|opcode|7 bits|操作码，标识指令类型|
|rd|5 bits|目标寄存器，存放结果|
|funct3|3 bits|功能码，标识具体操作|
|rs1|5 bits|源寄存器|
|imm[11:0]|12 bits|立即数，表示立即操作数|

##### 示例指令：

- **ADDI rd, rs1, imm**：将 `rs1` 的值和立即数 `imm` 相加，结果存入 `rd`。
- **LW rd, imm(rs1)**：从 `rs1 + imm` 计算出的内存地址加载一个字到 `rd`。

#### 3. **S 型指令（S-Type Instruction）**

S 型指令用于存储操作，即将寄存器中的数据存储到内存。

##### 格式：

|字段|位宽|说明|
|---|---|---|
|opcode|7 bits|操作码，标识指令类型|
|imm[4:0]|5 bits|立即数的低 5 位|
|funct3|3 bits|功能码，标识具体操作|
|rs1|5 bits|基址寄存器，计算存储地址|
|rs2|5 bits|要存储的源寄存器|
|imm[11:5]|7 bits|立即数的高 7 位|

##### 示例指令：

- **SW rs2, imm(rs1)**：将 `rs2` 的值存储到 `rs1 + imm` 计算出的内存地址。

#### 4. **B 型指令（SB-Type Instruction）**

SB 型指令用于条件分支操作，例如比较两个寄存器并基于结果进行跳转。

##### 格式：

|字段|位宽|说明|
|---|---|---|
|opcode|7 bits|操作码，标识指令类型|
|imm[11]|1 bit|立即数的第 12 位|
|imm[4:1]|4 bits|立即数的低 4 位|
|funct3|3 bits|功能码，标识具体操作|
|rs1|5 bits|第一个源寄存器|
|rs2|5 bits|第二个源寄存器|
|imm[10:5]|6 bits|立即数的中间 6 位|
|imm[12]|1 bit|立即数的第 13 位|

##### 示例指令：

- **BEQ rs1, rs2, offset**：如果 `rs1 == rs2`，则跳转到 `PC + offset`。

#### 5. **U 型指令（U-Type Instruction）**

U 型指令用于包含较大立即数的操作，例如加载高位立即数或生成较大的常数。

##### 格式：

|字段|位宽|说明|
|---|---|---|
|opcode|7 bits|操作码，标识指令类型|
|rd|5 bits|目标寄存器，存放结果|
|imm[31:12]|20 bits|高位立即数|

##### 示例指令：

- **LUI rd, imm**：将立即数 `imm` 加载到寄存器 `rd` 的高 20 位，低 12 位为 0。
- **AUIPC rd, imm**：将 `PC + imm` 的值存入寄存器 `rd`。

#### 6. **J 型指令（UJ-Type Instruction）**

UJ 型指令用于无条件跳转，如函数调用或程序跳转。

##### 格式：

| 字段         | 位宽      | 说明             |
| ---------- | ------- | -------------- |
| opcode     | 7 bits  | 操作码，标识指令类型     |
| rd         | 5 bits  | 目标寄存器，存放跳转后的地址 |
| imm[20]    | 1 bit   | 立即数的第 20位      |
| imm[10:1]  | 10 bits | 立即数的低 10 位     |
| imm[11]    | 1 bit   | 立即数的第 11 位     |
| imm[19:12] | 8 bits  | 立即数的中 8 位      |

##### 示例指令：

- **JAL rd, offset**：跳转到 `PC + offset`，并将 `PC + 4` 的值存入 `rd`。

#### 伪指令
![[Pasted image 20240910085514.png]]

#### 总结
- **R 型**：寄存器到寄存器的算术或逻辑操作。
- **I 型**：立即数运算、内存加载和某些控制指令。
- **S 型**：将数据存储到内存。
- **B 型**：条件分支跳转。
- **U 型**：加载高位立即数或计算较大常数。
- **J 型**：无条件跳转（如函数调用）。


### 指令集
#### 1. **整数计算指令集（I 指令集，RV 32 I/64 I/128 I）**
这些是 RISC-V 的基本整数指令，适用于 32 位、64 位和 128 位的 RISC-V 架构。
##### 算术指令：
- **ADD rd, rs 1, rs 2**：`rd = rs1 + rs2`（加法）
- **SUB rd, rs 1, rs 2**：`rd = rs1 - rs2`（减法）
- **LUI rd, imm**：将 20 位立即数 imm 左移 12 位，并放入 `rd`，即 `rd = imm << 12`（加载上半部分立即数）
- **AUIPC rd, imm**：`rd = PC + (imm << 12)`（相对 PC 加载上半部分立即数）
  
##### 逻辑指令：
- **AND rd, rs 1, rs 2**：`rd = rs1 & rs2`（按位与）
- **OR rd, rs 1, rs 2**：`rd = rs1 | rs2`（按位或）
- **XOR rd, rs 1, rs 2**：`rd = rs1 ^ rs2`（按位异或）

##### 移位指令：
- **SLL rd, rs 1, rs 2**：`rd = rs1 << rs2`（逻辑左移）
- **SRL rd, rs 1, rs 2**：`rd = rs1 >> rs2`（逻辑右移）
- **SRA rd, rs 1, rs 2**：`rd = rs1 >>> rs2`（算术右移）
  
##### 比较指令：
- **SLT rd, rs 1, rs 2**：`rd = (rs1 < rs2)`（有符号小于）
- **SLTU rd, rs 1, rs 2**：`rd = (rs1 < rs2)`（无符号小于）

##### 立即数运算：
- **ADDI rd, rs 1, imm**：`rd = rs1 + imm`（加立即数）
- **ANDI rd, rs 1, imm**：`rd = rs1 & imm`（与立即数）
- **ORI rd, rs 1, imm**：`rd = rs1 | imm`（或立即数）
- **XORI rd, rs 1, imm**：`rd = rs1 ^ imm`（异或立即数）
- **SLLI rd, rs 1, shamt**：`rd = rs1 << shamt`（逻辑左移立即数）
- **SRLI rd, rs 1, shamt**：`rd = rs1 >> shamt`（逻辑右移立即数）
- **SRAI rd, rs 1, shamt**：`rd = rs1 >>> shamt`（算术右移立即数）
- **SLTI rd, rs 1, imm**：`rd = (rs1 < imm)`（有符号立即数比较）
- **SLTIU rd, rs 1, imm**：`rd = (rs1 < imm)`（无符号立即数比较）

#### 2. **分支和跳转指令**

##### 条件分支：
- **BEQ rs 1, rs 2, offset**：如果 `rs1 == rs2`，跳转到 `PC + offset`
- **BNE rs 1, rs 2, offset**：如果 `rs1 != rs2`，跳转到 `PC + offset`
- **BLT rs 1, rs 2, offset**：如果 `rs1 < rs2`（有符号），跳转到 `PC + offset`
- **BGE rs 1, rs 2, offset**：如果 `rs1 >= rs2`（有符号），跳转到 `PC + offset`
- **BLTU rs 1, rs 2, offset**：如果 `rs1 < rs2`（无符号），跳转到 `PC + offset`
- **BGEU rs 1, rs 2, offset**：如果 `rs1 >= rs2`（无符号），跳转到 `PC + offset`

##### 无条件跳转：
- **JAL rd, offset**：跳转到 `PC + offset` 并将 `PC + 4` 保存到 `rd` 中（用于函数调用）
- **JALR rd, rs 1, offset**：跳转到 `(rs1 + offset) & ~1`，并将 `PC + 4` 保存到 `rd` 中（寄存器间接跳转）

#### 3. **内存访问指令**

##### 加载指令：
- **LB rd, offset (rs 1)**：从 `rs1 + offset` 的内存地址处加载一个字节，符号扩展后存入 `rd`
- **LBU rd, offset (rs 1)**：从 `rs1 + offset` 的内存地址处加载一个字节，零扩展后存入 `rd`
- **LH rd, offset (rs 1)**：从 `rs 1 + offset` 的内存地址处加载半字，符号扩展后存入 `rd`
- **LHU rd, offset (rs 1)**：从 `rs 1 + offset` 的内存地址处加载半字，零扩展后存入 `rd`
- **LW rd, offset (rs 1)**：从 `rs 1 + offset` 的内存地址处加载一个字（32 位），存入 `rd`
- **LD rd, offset (rs 1)**：从 `rs 1 + offset` 的内存地址处加载双字（64 位），存入 `rd`（64 位架构）

##### 存储指令：
- **SB rs 2, offset (rs 1)**：将寄存器 `rs 2` 的最低 8 位存储到 `rs 1 + offset` 的内存地址处
- **SH rs 2, offset (rs 1)**：将寄存器 `rs 2` 的最低 16 位存储到 `rs 1 + offset` 的内存地址处
- **SW rs 2, offset (rs 1)**：将寄存器 `rs 2` 的 32 位存储到 `rs 1 + offset` 的内存地址处
- **SD rs 2, offset (rs 1)**：将寄存器 `rs 2` 的 64 位存储到 `rs 1 + offset` 的内存地址处（64 位架构）

#### 4. **原子性指令（A 扩展，RV 32 A/64 A）**

原子操作指令用于多线程环境中的同步操作。

- **LR. W rd, rs 1**：加载并保留 32 位字（load-reserved）
- **SC. W rd, rs 2, rs 1**：尝试存储条件（store-conditional），如果成功则将 `rs 2` 存储到 `rs 1`，并将结果状态存储到 `rd`
- **AMOSWAP. W rd, rs 2, rs 1**：交换 `rs 2` 和内存中 `rs 1` 地址处的 32 位字
- **AMOADD. W rd, rs 2, rs 1**：将 `rs 2` 加到 `rs 1` 地址处的 32 位字，并将结果存储到 `rd`

#### 5. **乘除法指令（M 扩展，RV 32 M/64 M）**

RISC-V M 扩展用于整数乘法和除法操作。

- **MUL rd, rs 1, rs 2**：`rd = rs 1 * rs 2`（乘法）
- **MULH rd, rs 1, rs 2**：`rd = (rs 1 * rs 2)` 高 32 位（有符号乘法）
- **MULHU rd, rs 1, rs 2**：`rd = (rs 1 * rs 2)` 高 32 位（无符号乘法）
- **DIV rd, rs 1, rs 2**：`rd = rs 1 / rs 2`（有符号除法）
- **DIVU rd, rs 1, rs 2**：`rd = rs 1 / rs 2`（无符号除法）
- **REM rd, rs 1, rs 2**：`rd = rs 1 % rs 2`（有符号取余）
- **REMU rd, rs 1, rs 2**：`rd = rs 1 % rs 2`（无符号取余）

#### 6. **浮点运算指令（F 和 D 扩展，RV 32 F/64 F/32 D/64 D）**

浮点扩展支持单精度（32 位）和双精度（64 位）浮点数运算。

- **FADD. S rd, rs 1, rs 2**：浮点加法（单精度）
- **FSUB. S rd, rs 1, rs 2**：浮点减法（单精度）
- **FMUL. S rd, rs 1, rs 2**：浮点乘法（单精度）
- **FDIV. S rd, rs 1, rs2** ：浮点除法（单精度）
- **FADD. D rd, rs 1, rs 2**：浮点加法（双精度）
- **FSUB. D rd, rs 1, rs 2**：浮点减法（双精度）

#### 7. **系统控制指令**

- **ECALL**：系统调用
- **EBREAK**：调试断点
- **FENCE**：内存同步屏障，用于确保内存操作的顺序

### 指令详解
#### JAL 与 JALR
当然可以。在RISC-V架构中，`jal`（Jump and Link）J 类型和 `jalr`（Jump and Link Register）I 类型是两种用于条件分支的指令。这两种指令的主要功能是在跳转到另一个地址执行代码的同时保存返回地址，以便稍后可以恢复程序的执行。下面我们将分别介绍这两种指令的功能、用途以及它们之间的区别。

##### jal (Jump and Link)

`jal` 指令是一个无条件跳转指令，它会跳转到一个固定的地址，并且把当前指令的下一条指令的地址（即返回地址）保存到寄存器 `pc+4` 中（因为RISC-V指令长度固定为4字节）。`jal` 的格式如下：

```
jal rd, imm
```

其中：
- `rd` 是用来存储返回地址的寄存器。
- `imm` 是一个20位的立即数，用于计算目标地址。

`jal` 指令通常用于函数调用。当函数执行完毕后，可以通过从 `rd` 寄存器中读取返回地址来恢复之前的执行位置。

##### jalr (Jump and Link Register)

`jalr` 指令也是用于跳转，但它跳转的目标地址是由寄存器的值加上一个偏移量计算得到的。它的格式如下：

```
jalr rd, rs1, imm
```

其中：
- `rd` 是用来存储返回地址的寄存器。
- `rs1` 包含了基址，跳转的目标地址 = `rs1 + imm`。
- `imm` 是一个12位的立即数偏移量。

`jalr` 指令通常用于间接跳转，即跳转到由寄存器中的值指定的位置。这在实现函数调用表或者动态链接时非常有用。

##### 区别

- **目标地址计算方式**：`jal` 使用立即数来计算目标地址，而 `jalr` 使用寄存器值加上立即数偏移量来计算。
- **灵活性**：`jalr` 更加灵活，因为它可以跳转到由运行时决定的地址，而 `jal` 的地址是静态确定的。
- **典型用途**：`jal` 主要用于直接函数调用，而 `jalr` 用于间接跳转，比如基于查找表的函数调用。

##### 在流水线中的影响

在五级流水线中，`jal` 和 `jalr` 都会引起分支预测的问题。为了保持流水线的连续性，通常会使用分支预测技术来猜测分支的方向。如果预测错误，则可能需要冲洗（flush）流水线。

对于 `jal`，由于它是无条件跳转，分支预测相对简单，通常可以预测为总是跳转。而对于 `jalr`，因为它是基于寄存器的值，所以预测可能更加复杂。

总的来说，`jal` 和 `jalr` 都是重要的控制转移指令，它们在RISC-V架构中用于实现函数调用和其他形式的程序流程控制。在现代处理器中，通过高效的分支预测和流水线管理机制，可以减少这些指令带来的性能影响。


