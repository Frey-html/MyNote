* 没有频率要求，可以尝试降低时钟周期保证下板子不出现时序问题

* 补实验过程出现注意点
	* L0
		* 注意生成bit流之后，bit流文件的路径
		* 注意引脚约束（工具约束不能直接用默认，注意点平标准和是否全部约束）
		* 工具约束在综合之后（约束完需要重新综合），直接写文件约束不需要再次综合
		* 下板子前先多跑跑测试debug
		* 当前Vivado暂不支持.edf文件的仿真，仿真过程中不会报错，但是无有效波形输出
	* 模块生成：
		* ROM可以在需要的工程里直接生成，并关联初始化.coe文件

* Stall和Flush，阶段寄存器Stall时寄存器保留上一时钟周期的值，而Flush则为寄存器有效值全部置零
### Lab1
#### 重点知识
* 停顿，冲刷实现原理：[[Stall, flush and reset]]
* 冒险概述：[[数据冒险与控制冒险概述]]
* **实现模块：** Hazard detection， rv32i core（主要为多路选择器）， cpu controller
![[Pasted image 20231021100622.png|500]]

#### Hazard梳理
![[Pasted image 20231021095048.png|500]]
##### 1.结构冒险
* 原因：在WB阶段写寄存器时同时有ID阶段的指令读寄存器
* 解决方式：寄存器在时钟上边沿写，下边沿读

##### 2.数据冒险
![[Pasted image 20231021095836.png|500]]
在此实验中DataPath加入Foward主要是为了解决数据冒险，其发生于指令出现RAW(read after write)情况，寄存器读取发生在ID阶段而写入在三个时钟周期后的WB阶段，可能出现后面指令需要读取的寄存器数据前面指令在读取时尚未完成写入，形成数据冒险。
根据指令的类型与出现顺序，考虑不同指令在写寄存器数据时该数据产生的时钟周期，大部分写寄存器数据在EXE阶段由ALU产生，L类型指令写寄存器数据在MEM阶段产生，我们可以将RAW分为以下五种情况：
1. **非L类写寄存器指令后紧接读相应寄存器**
	解决方法：将EXE阶段的ALU运算结果ALUout_EXE forward到ID阶段，作为读寄存器输出提供给紧接的指令。
2. **非L类写寄存器指令后隔一条出现读相应寄存器指令**
	解决方法：将此时处在MEM阶段该写寄存器指令的ALU运算结果ALUout_MEM forward到ID阶段，作为读寄存器输出提供给紧接的指令。
3. **L类写寄存器（读存储器）指令后紧接S类型写存储器（读相应寄存器）指令**
	解决方法：由于读写存储器均发生在MEM阶段，在L类写寄存器指令读出存储器数据后S类处于EXE阶段，可以将数据从MEM读取结果Datain_MEM forward到EXE阶段。
4. **L类写寄存器指令后隔一条出现读相应寄存器指令**
	解决方法：此时无论是S类还是非S类指令，均可以通过MEM读取结果Datain_MEM forward到ID阶段解决。
5. **L类写寄存器指令后紧接非S类型读相应寄存器指令**
	解决方法：此时只能将身后指令stall一个时钟周期，之后转变为第四类情况通过MEM读取结果Datain_MEM forward到ID阶段解决。![[Pasted image 20231021101741.png]]
##### 3.控制冒险
* 策略：Predict branch taken
* ID阶段在检测到跳转指令后由Hazard Control Unit输出控制信号，Flush掉IF-ID寄存器的一个cycle使一个周期后IF取到的地址为ID阶段当前时钟末上边沿产出的需要跳转正确地址
![[Pasted image 20231022092056.png]]

#### 重点控制信号
##### 