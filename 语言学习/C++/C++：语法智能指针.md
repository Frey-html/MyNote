[【C++智能指针】unique_ptr的源码详解以及应用实例_uniqueptr源码分析-CSDN博客](https://blog.csdn.net/b_r_ight/article/details/138039520)


### 1. **野指针 (Dangling Pointer)**

在 C++中，**野指针**指的是指向无效内存地址的指针。由于野指针指向的内存位置可能已经被释放、被覆盖或根本没有被分配，这种指针的解引用可能会导致程序崩溃或行为异常，出现**未定义行为**（undefined behavior）。野指针常常由以下几种情况引起：


#### 1.1 野指针的几种常见情形

- **指针没有被初始化**：如果指针在声明时未被初始化，它的值是随机的，很可能指向一个未知的内存地址，成为野指针。
  ```cpp
  int *p;  // 未初始化的指针，p的值是随机的
  *p = 10;  // 未定义行为
  ```

- **指针指向的内存被释放**：当一个指针指向的内存被释放（例如通过 `delete` 或 `free` 操作），指针仍然保持着原来的地址，但该内存位置已被释放或重新分配。这时，指针就成为了野指针。
  ```cpp
  int *p = new int(10);
  delete p;  // p指向的内存已被释放
  *p = 20;   // 野指针，未定义行为
  ```

- **栈上的指针超过其作用域**：当一个指针指向某个局部变量，而这个局部变量已经离开其作用域，该指针成为野指针。
  ```cpp
  int* f() {
      int x = 10;
      return &x;  // 返回局部变量的地址
  }

  int* p = f();  // p成为野指针
  ```

#### 1.2 避免野指针的策略

- **指针初始化**：始终在声明指针时进行初始化。可以将指针初始化为 `nullptr`，以确保指针在没有指向有效内存时不会被错误地使用。
  ```cpp
  int* p = nullptr;  // 安全的空指针
  ```

- **释放后置空**：在释放指针指向的内存后，将该指针置为 `nullptr`，防止误用野指针。
  ```cpp
  int* p = new int(10);
  delete p;
  p = nullptr;  // 避免成为野指针
  ```

- **避免返回局部变量的地址**：不要返回指向局部变量的指针，因为这些变量在函数返回后会超出作用域，导致野指针。

---

### 2. **安全指针**

为了避免野指针问题，C++标准库提供了两种智能指针类型，分别是 **`std::unique_ptr`** 和 **`std::shared_ptr`**，这些被称为**智能指针**或**安全指针**，用于自动管理动态分配的内存，以防止内存泄漏和指针悬空问题。

#### 2.1 `std::unique_ptr` - 独占指针

**`std::unique_ptr`** 是一种**独占所有权**的智能指针，意味着同一时间内只能有一个指针拥有该对象的所有权。它的主要特性是，当 `std::unique_ptr` 超出作用域时，它会自动释放内存，无需手动 `delete`。

##### 用法示例
```cpp
#include <memory>  // 引入unique_ptr

int main() {
    std::unique_ptr<int> p1 = std::make_unique<int>(10);  // 创建一个unique_ptr
    *p1 = 20;  // 使用它像普通指针一样
    // 当p1超出作用域时，内存会自动释放
}
```

##### 特点
- **独占所有权**：不能复制 `std::unique_ptr`，只能通过**转移所有权**（移动语义）来传递指针。
  ```cpp
  std::unique_ptr<int> p2 = std::move(p1);  // 将p1的所有权转移给p2
  // 现在p1不再拥有指针，p1变为nullptr
  ```
- **自动释放**：当 `unique_ptr` 超出其作用域时，它会自动调用 `delete` 释放其所指向的对象，避免内存泄漏。

#### 2.2 `std::shared_ptr` - 共享指针

**`std::shared_ptr`** 是一种**共享所有权**的智能指针，允许多个指针同时指向同一个对象。当最后一个指向该对象的 `shared_ptr` 被销毁时，内存才会被释放。

##### 用法示例
```cpp
#include <memory>  // 引入shared_ptr

int main() {
    std::shared_ptr<int> p1 = std::make_shared<int>(10);  // 创建一个shared_ptr
    std::shared_ptr<int> p2 = p1;  // p1和p2共享同一个对象的所有权
    *p1 = 20;
    // 当最后一个指向对象的shared_ptr（p1和p2）销毁时，内存会自动释放
}
```

##### 特点
- **引用计数**：`shared_ptr` 内部维护一个**引用计数器**，每次复制时计数器加 1，销毁时计数器减 1。只有当计数器为 0 时，才会释放对象。
- **自动释放**：和 `unique_ptr` 类似，当最后一个指向对象的 `shared_ptr` 被销毁时，自动释放内存。
- **线程安全**：对引用计数的操作是线程安全的，可以在多线程环境下使用。

#### 2.3 `std::weak_ptr` - 弱指针

**`std::weak_ptr`** 是一种不影响对象生命周期的智能指针。它用于**打破循环引用**，避免 `shared_ptr` 的循环依赖问题。

##### 用法示例
```cpp
#include <memory>

int main() {
    std::shared_ptr<int> sp = std::make_shared<int>(10);
    std::weak_ptr<int> wp = sp;  // 创建一个weak_ptr指向同一对象
    // weak_ptr不会增加引用计数
    if (auto temp = wp.lock()) {  // lock() 会返回一个shared_ptr
        // 可以安全地使用temp
    }
}
```

##### 特点
- **不增加引用计数**：`weak_ptr` 不会影响所指向对象的生命周期，也不会增加引用计数。
- **检查对象是否存在**：可以使用 `weak_ptr.lock()` 检查对象是否仍然存在，并获得一个 `shared_ptr`。

---

### 3. **野指针与安全指针的对比**

| 特性                | 野指针 (Dangling Pointer)                     | 安全指针 (Smart Pointer)                   |
|---------------------|----------------------------------------------|--------------------------------------------|
| **内存管理**        | 手动管理，容易出错导致内存泄漏或重复释放      | 自动管理，智能指针自动释放内存              |
| **生命周期控制**    | 程序员需要手动控制指针生命周期                | 智能指针通过引用计数或独占所有权控制生命周期 |
| **安全性**          | 不安全，容易出现悬空指针、重复释放等问题      | 安全，自动防止悬空指针和内存泄漏            |
| **性能开销**        | 性能较高，但容易出错                          | 引用计数或所有权转移有轻微的性能开销        |
| **线程安全**        | 需要手动处理                                  | `shared_ptr` 的引用计数是线程安全的         |

### 4. **总结**

- **野指针**是 C++编程中常见的错误来源，会导致严重的运行时错误，如内存泄漏或程序崩溃。避免野指针的关键是正确管理内存，包括初始化指针、释放后将指针置空、避免使用指向局部变量的指针。
  
- **智能指针**（`std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr`）是 C++提供的安全指针机制，能够帮助程序员自动管理动态内存，避免内存泄漏和野指针问题。智能指针通过引用计数、所有权转移等机制，保证了指针的安全性和内存的自动释放，使得 C++的内存管理更加简洁和安全。

