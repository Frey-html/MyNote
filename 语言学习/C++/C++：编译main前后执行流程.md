在 C++ 中，`main` 函数是程序的入口点，程序的执行流程并不仅仅从 `main` 函数开始，也不仅在 `main` 函数结束时终止。实际上，C++ 运行时系统在 `main` 函数执行之前和之后都会进行一系列重要的初始化和清理工作。这些操作主要由 C++ 运行时库和操作系统完成，确保程序的正确执行。
#review

### 一、`main` 函数执行之前的操作

在 `main` 函数执行之前，C++ 运行时会进行以下操作：

#### 1. **启动运行时环境**
   操作系统在加载程序时，会加载必要的库和执行环境，这涉及以下步骤：
   - **加载可执行文件**：操作系统将程序的可执行文件加载到内存中，进行动态链接（加载动态库/共享库）。
   - **准备执行堆栈**：操作系统为程序分配运行所需的栈空间，准备参数和环境变量。

#### 2. **静态/全局对象的初始化**
   在 `main` 函数执行之前，所有**全局对象**、**静态对象**以及**命名空间范围的静态变量**都会被初始化。C++ 保证这些对象的初始化顺序遵循以下规则：
   - 对于具有编译期常量值的对象（如 `const int`），编译器会将其直接初始化为常量。
   - 对于复杂的对象，构造函数会在 `main` 函数执行前调用。
   
   具体步骤包括：
   - **静态变量初始化**：全局和静态变量按其声明顺序进行初始化。这包括调用全局/静态对象的构造函数。
   - **静态成员变量初始化**：静态类成员在 `main` 函数执行前初始化。

   例如：
   ```cpp
   class Test {
   public:
       Test() { std::cout << "Test Constructor\n"; }
       ~Test() { std::cout << "Test Destructor\n"; }
   };

   Test globalObj;  // 这是一个全局对象

   int main() {
       std::cout << "Main Function\n";
       return 0;
   }
   ```
   输出将显示：
   ```
   Test Constructor
   Main Function
   Test Destructor
   ```

#### 3. **动态库初始化**
   如果程序依赖于动态链接库（如 `.so` 或 `.dll`），这些库的全局对象也会在 `main` 函数之前被初始化。动态库的初始化顺序通常由系统管理，且与全局/静态对象初始化的顺序一起被考虑。

#### 4. **调用预处理器宏的钩子函数**
   C++ 提供了一些预处理器宏可以在 `main` 函数执行前执行代码。常见的有：
   - **`__attribute__((constructor))`**（GCC/Clang）：可以将某些函数标记为构造函数，保证它们在 `main` 函数之前执行。
   - **`__attribute__((destructor))`**：标记为析构函数的函数将在程序结束时执行。

   示例：
   ```cpp
   #include <iostream>

   void __attribute__((constructor)) before_main() {
       std::cout << "Before main\n";
   }

   void __attribute__((destructor)) after_main() {
       std::cout << "After main\n";
   }

   int main() {
       std::cout << "Main Function\n";
       return 0;
   }
   ```
   输出：
   ```
   Before main
   Main Function
   After main
   ```

---

### 二、`main` 函数执行之后的操作

当 `main` 函数返回或调用 `exit()` 时，C++ 运行时会进行以下操作：

#### 1. **处理 `atexit()` 注册的函数**
   C++ 提供了 `atexit()` 函数，允许开发者注册一些在程序退出时执行的回调函数。这些函数会在 `main` 返回后被调用。
   
   例如：
   ```cpp
   #include <cstdlib>
   #include <iostream>

   void cleanup() {
       std::cout << "Cleanup Function\n";
   }

   int main() {
       std::atexit(cleanup);
       std::cout << "Main Function\n";
       return 0;
   }
   ```
   输出：
   ```
   Main Function
   Cleanup Function
   ```

#### 2. **静态/全局对象的析构**
   在 `main` 函数执行完毕后，所有全局和静态对象会按照它们构造的相反顺序被销毁。即全局变量和静态变量的析构函数会被调用，释放资源，保证系统在退出时不留下未释放的内存或文件句柄等资源。

   上面提到的例子中，全局对象 `globalObj` 在 `main` 返回后会调用它的析构函数。

#### 3. **C++ 运行时环境清理**
   - 释放堆栈和堆内存：运行时环境会释放程序在执行期间分配的所有内存（例如堆栈、堆）。
   - 关闭文件描述符和释放系统资源：包括关闭所有打开的文件、网络连接和其他资源。
   - 释放动态库：如果程序使用了动态库，操作系统会卸载这些库。

#### 4. **返回操作系统**
   最终，程序返回到操作系统，返回值通常由 `main` 函数的返回值（或者通过 `exit()` 函数传递的值）决定。操作系统会接收这个返回值，并将其作为程序退出状态码。

---

### 三、程序异常终止时的操作

如果程序异常终止（例如由于未捕获的异常、信号导致的崩溃），某些清理操作可能无法按正常顺序执行，但 C++ 仍会尽可能地进行一些资源释放和清理：

1. **未捕获异常**：如果未捕获的异常传播到了 `main` 函数之外，程序会调用 `std::terminate()`，触发异常处理流程。可以通过 `std::set_terminate()` 自定义未捕获异常的处理行为。
   
2. **信号处理**：如果程序因信号（如 `SIGSEGV`）崩溃，系统可能会在崩溃后直接终止程序，某些清理操作（如静态对象析构）可能不会执行。开发者可以使用 `signal()` 或 `sigaction()` 来注册信号处理函数以捕获信号并进行适当的处理。

---

### 总结

C++ 程序在 `main` 函数之前和之后会有许多复杂的初始化和清理操作：
- 在 `main` 函数之前，C++ 会加载运行时环境、初始化全局和静态对象，并处理动态库的加载。
- 在 `main` 函数之后，C++ 运行时会执行 `atexit()` 注册的函数、销毁静态和全局对象，并释放资源。
- 如果程序异常终止，C++ 运行时也会尝试执行一些清理操作，如调用 `terminate` 或信号处理函数。

这些操作确保了程序的初始化和终止过程是安全和有序的，使得资源能够正确地分配和释放。