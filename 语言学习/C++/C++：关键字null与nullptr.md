`nullptr` 和 `NULL` 都用于表示空指针（即不指向任何有效的内存地址），但它们在 C++ 中有一些重要的区别。
#review 
### 1. **类型不同**

- **`nullptr`**：C++11 引入的关键字，它的类型是 `std::nullptr_t`，是一个专门用于表示空指针的类型。它可以隐式转换为任何指针类型（如 `int*`、`char*` 等），并且不会与其他类型混淆。
  
- **`NULL`**：`NULL` 是在 C 和 C++ 中使用的宏，它通常定义为 `0`（或在某些实现中可能定义为 `((void*)0)`）。由于 `NULL` 的本质是整数，因此它本质上是一个整数常量。

### 2. **隐式转换行为**

- **`nullptr`**：因为 `nullptr` 是一个专门的空指针类型，它不会与整数类型发生混淆。它可以安全地转换为任何指针类型，但不能转换为整数类型。
  
  ```cpp
  int* p = nullptr;   // 正确，nullptr 可以转换为指针类型
  int i = nullptr;    // 错误，nullptr 不能转换为整数类型
  ```

- **`NULL`**：`NULL` 是一个整数常量（通常为 `0`），因此它在某些上下文中可能与整数产生混淆。
  
  ```cpp
  int* p = NULL;      // 正确，NULL 可以表示空指针
  int i = NULL;       // 可能编译通过，因为 NULL 是 0，可以赋值给整数
  ```

  因此，`NULL` 可能引发一些潜在的错误，特别是在函数重载时，`NULL` 可能被解释为 `int` 而非指针类型。

### 3. **函数重载的区别**

在 C++ 中，当涉及到函数重载时，使用 `nullptr` 可以避免二义性，而 `NULL` 可能会导致歧义。

例如，考虑以下函数重载：

```cpp
void f(int);
void f(int*);

int main() {
    f(0);         // 调用 f(int)
    f(NULL);      // 调用 f(int)，因为 NULL 是 0
    f(nullptr);   // 调用 f(int*)，因为 nullptr 是指针类型
}
```

在这个例子中：
- `f(0)` 和 `f(NULL)` 都调用了 `f(int)`，因为 `0` 和 `NULL` 都是整数常量。
- `f(nullptr)` 则调用了 `f(int*)`，因为 `nullptr` 是指针类型，没有歧义。

### 4. **兼容性**

- **`NULL`**：`NULL` 作为 C 的遗留特性，既在 C 又在 C++ 中都存在，并且长期以来在两者中都被广泛使用。然而，由于它本质上是 `0`，在 C++ 中可能导致歧义和类型不安全。
  
- **`nullptr`**：`nullptr` 是 C++11 引入的一个新特性，它为空指针提供了类型安全和明确性。它避免了 `NULL` 与整数 `0` 混淆的问题，建议在现代 C++ 编程中使用。

### 5. **总结**

| 特性          | `nullptr`                    | `NULL`                       |
|---------------|------------------------------|------------------------------|
| 引入版本      | C++11                         | C 和 C++                     |
| 类型          | `std::nullptr_t`              | 通常为 `int` 或 `void*`       |
| 类型安全      | 是                            | 否                            |
| 隐式转换      | 可转换为任何指针类型           | 可转换为指针和整数类型         |
| 重载歧义      | 不会产生重载歧义               | 可能导致重载歧义               |
| 建议使用      | 是（现代 C++ 中的最佳选择）    | 否（仅为兼容性目的）          |

### 推荐使用 `nullptr`
在现代 C++ 中，建议使用 `nullptr`，因为它更加类型安全、明确，并且能够避免 `NULL` 带来的潜在问题，尤其是在涉及到函数重载或模板编程时。